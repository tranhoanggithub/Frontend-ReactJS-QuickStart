{"ast":null,"code":"import { isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, isTagElement } from '@formatjs/icu-messageformat-parser';\nimport { MissingValueError, InvalidValueError, ErrorCode, FormatError, InvalidValueTypeError } from './error';\nexport var PART_TYPE;\n(function (PART_TYPE) {\n  PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n  PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (PART_TYPE = {}));\nfunction mergeLiteral(parts) {\n  if (parts.length < 2) {\n    return parts;\n  }\n  return parts.reduce(function (all, part) {\n    var lastPart = all[all.length - 1];\n    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {\n      all.push(part);\n    } else {\n      lastPart.value += part.value;\n    }\n    return all;\n  }, []);\n}\nexport function isFormatXMLElementFn(el) {\n  return typeof el === 'function';\n}\n// TODO(skeleton): add skeleton support\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue,\n// For debugging\noriginalMessage) {\n  // Hot path for straight simple msg translations\n  if (els.length === 1 && isLiteralElement(els[0])) {\n    return [{\n      type: PART_TYPE.literal,\n      value: els[0].value\n    }];\n  }\n  var result = [];\n  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n    var el = els_1[_i];\n    // Exit early for string parts.\n    if (isLiteralElement(el)) {\n      result.push({\n        type: PART_TYPE.literal,\n        value: el.value\n      });\n      continue;\n    }\n    // TODO: should this part be literal type?\n    // Replace `#` in plural rules with the actual numeric value.\n    if (isPoundElement(el)) {\n      if (typeof currentPluralValue === 'number') {\n        result.push({\n          type: PART_TYPE.literal,\n          value: formatters.getNumberFormat(locales).format(currentPluralValue)\n        });\n      }\n      continue;\n    }\n    var varName = el.value;\n    // Enforce that all required values are provided by the caller.\n    if (!(values && varName in values)) {\n      throw new MissingValueError(varName, originalMessage);\n    }\n    var value = values[varName];\n    if (isArgumentElement(el)) {\n      if (!value || typeof value === 'string' || typeof value === 'number') {\n        value = typeof value === 'string' || typeof value === 'number' ? String(value) : '';\n      }\n      result.push({\n        type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n        value: value\n      });\n      continue;\n    }\n    // Recursively format plural and select parts' option — which can be a\n    // nested pattern structure. The choosing of the option to use is\n    // abstracted-by and delegated-to the part helper object.\n    if (isDateElement(el)) {\n      var style = typeof el.style === 'string' ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if (isTimeElement(el)) {\n      var style = typeof el.style === 'string' ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if (isNumberElement(el)) {\n      var style = typeof el.style === 'string' ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      if (style && style.scale) {\n        value = value * (style.scale || 1);\n      }\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getNumberFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if (isTagElement(el)) {\n      var children = el.children,\n        value_1 = el.value;\n      var formatFn = values[value_1];\n      if (!isFormatXMLElementFn(formatFn)) {\n        throw new InvalidValueTypeError(value_1, 'function', originalMessage);\n      }\n      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n      var chunks = formatFn(parts.map(function (p) {\n        return p.value;\n      }));\n      if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n      }\n      result.push.apply(result, chunks.map(function (c) {\n        return {\n          type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n          value: c\n        };\n      }));\n    }\n    if (isSelectElement(el)) {\n      var opt = el.options[value] || el.options.other;\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n      continue;\n    }\n    if (isPluralElement(el)) {\n      var opt = el.options[\"=\" + value];\n      if (!opt) {\n        if (!Intl.PluralRules) {\n          throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", ErrorCode.MISSING_INTL_API, originalMessage);\n        }\n        var rule = formatters.getPluralRules(locales, {\n          type: el.pluralType\n        }).select(value - (el.offset || 0));\n        opt = el.options[rule] || el.options.other;\n      }\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n      continue;\n    }\n  }\n  return mergeLiteral(result);\n}","map":{"version":3,"names":["isArgumentElement","isDateElement","isDateTimeSkeleton","isLiteralElement","isNumberElement","isNumberSkeleton","isPluralElement","isPoundElement","isSelectElement","isTimeElement","isTagElement","MissingValueError","InvalidValueError","ErrorCode","FormatError","InvalidValueTypeError","PART_TYPE","mergeLiteral","parts","length","reduce","all","part","lastPart","type","literal","push","value","isFormatXMLElementFn","el","formatToParts","els","locales","formatters","formats","values","currentPluralValue","originalMessage","result","_i","els_1","getNumberFormat","format","varName","String","object","style","date","parsedOptions","undefined","getDateTimeFormat","time","number","scale","children","value_1","formatFn","chunks","map","p","Array","isArray","apply","c","opt","options","other","Object","keys","Intl","PluralRules","MISSING_INTL_API","rule","getPluralRules","pluralType","select","offset"],"sources":["C:/Users/Admin/Desktop/LEARN REACTJS/Frontend-ReactJS-QuickStart/node_modules/intl-messageformat/lib/src/formatters.js"],"sourcesContent":["import { isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, isTagElement, } from '@formatjs/icu-messageformat-parser';\r\nimport { MissingValueError, InvalidValueError, ErrorCode, FormatError, InvalidValueTypeError, } from './error';\r\nexport var PART_TYPE;\r\n(function (PART_TYPE) {\r\n    PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\r\n    PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\r\n})(PART_TYPE || (PART_TYPE = {}));\r\nfunction mergeLiteral(parts) {\r\n    if (parts.length < 2) {\r\n        return parts;\r\n    }\r\n    return parts.reduce(function (all, part) {\r\n        var lastPart = all[all.length - 1];\r\n        if (!lastPart ||\r\n            lastPart.type !== PART_TYPE.literal ||\r\n            part.type !== PART_TYPE.literal) {\r\n            all.push(part);\r\n        }\r\n        else {\r\n            lastPart.value += part.value;\r\n        }\r\n        return all;\r\n    }, []);\r\n}\r\nexport function isFormatXMLElementFn(el) {\r\n    return typeof el === 'function';\r\n}\r\n// TODO(skeleton): add skeleton support\r\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue, \r\n// For debugging\r\noriginalMessage) {\r\n    // Hot path for straight simple msg translations\r\n    if (els.length === 1 && isLiteralElement(els[0])) {\r\n        return [\r\n            {\r\n                type: PART_TYPE.literal,\r\n                value: els[0].value,\r\n            },\r\n        ];\r\n    }\r\n    var result = [];\r\n    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\r\n        var el = els_1[_i];\r\n        // Exit early for string parts.\r\n        if (isLiteralElement(el)) {\r\n            result.push({\r\n                type: PART_TYPE.literal,\r\n                value: el.value,\r\n            });\r\n            continue;\r\n        }\r\n        // TODO: should this part be literal type?\r\n        // Replace `#` in plural rules with the actual numeric value.\r\n        if (isPoundElement(el)) {\r\n            if (typeof currentPluralValue === 'number') {\r\n                result.push({\r\n                    type: PART_TYPE.literal,\r\n                    value: formatters.getNumberFormat(locales).format(currentPluralValue),\r\n                });\r\n            }\r\n            continue;\r\n        }\r\n        var varName = el.value;\r\n        // Enforce that all required values are provided by the caller.\r\n        if (!(values && varName in values)) {\r\n            throw new MissingValueError(varName, originalMessage);\r\n        }\r\n        var value = values[varName];\r\n        if (isArgumentElement(el)) {\r\n            if (!value || typeof value === 'string' || typeof value === 'number') {\r\n                value =\r\n                    typeof value === 'string' || typeof value === 'number'\r\n                        ? String(value)\r\n                        : '';\r\n            }\r\n            result.push({\r\n                type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,\r\n                value: value,\r\n            });\r\n            continue;\r\n        }\r\n        // Recursively format plural and select parts' option — which can be a\r\n        // nested pattern structure. The choosing of the option to use is\r\n        // abstracted-by and delegated-to the part helper object.\r\n        if (isDateElement(el)) {\r\n            var style = typeof el.style === 'string'\r\n                ? formats.date[el.style]\r\n                : isDateTimeSkeleton(el.style)\r\n                    ? el.style.parsedOptions\r\n                    : undefined;\r\n            result.push({\r\n                type: PART_TYPE.literal,\r\n                value: formatters\r\n                    .getDateTimeFormat(locales, style)\r\n                    .format(value),\r\n            });\r\n            continue;\r\n        }\r\n        if (isTimeElement(el)) {\r\n            var style = typeof el.style === 'string'\r\n                ? formats.time[el.style]\r\n                : isDateTimeSkeleton(el.style)\r\n                    ? el.style.parsedOptions\r\n                    : undefined;\r\n            result.push({\r\n                type: PART_TYPE.literal,\r\n                value: formatters\r\n                    .getDateTimeFormat(locales, style)\r\n                    .format(value),\r\n            });\r\n            continue;\r\n        }\r\n        if (isNumberElement(el)) {\r\n            var style = typeof el.style === 'string'\r\n                ? formats.number[el.style]\r\n                : isNumberSkeleton(el.style)\r\n                    ? el.style.parsedOptions\r\n                    : undefined;\r\n            if (style && style.scale) {\r\n                value =\r\n                    value *\r\n                        (style.scale || 1);\r\n            }\r\n            result.push({\r\n                type: PART_TYPE.literal,\r\n                value: formatters\r\n                    .getNumberFormat(locales, style)\r\n                    .format(value),\r\n            });\r\n            continue;\r\n        }\r\n        if (isTagElement(el)) {\r\n            var children = el.children, value_1 = el.value;\r\n            var formatFn = values[value_1];\r\n            if (!isFormatXMLElementFn(formatFn)) {\r\n                throw new InvalidValueTypeError(value_1, 'function', originalMessage);\r\n            }\r\n            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\r\n            var chunks = formatFn(parts.map(function (p) { return p.value; }));\r\n            if (!Array.isArray(chunks)) {\r\n                chunks = [chunks];\r\n            }\r\n            result.push.apply(result, chunks.map(function (c) {\r\n                return {\r\n                    type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,\r\n                    value: c,\r\n                };\r\n            }));\r\n        }\r\n        if (isSelectElement(el)) {\r\n            var opt = el.options[value] || el.options.other;\r\n            if (!opt) {\r\n                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\r\n            }\r\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\r\n            continue;\r\n        }\r\n        if (isPluralElement(el)) {\r\n            var opt = el.options[\"=\" + value];\r\n            if (!opt) {\r\n                if (!Intl.PluralRules) {\r\n                    throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", ErrorCode.MISSING_INTL_API, originalMessage);\r\n                }\r\n                var rule = formatters\r\n                    .getPluralRules(locales, { type: el.pluralType })\r\n                    .select(value - (el.offset || 0));\r\n                opt = el.options[rule] || el.options.other;\r\n            }\r\n            if (!opt) {\r\n                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\r\n            }\r\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\r\n            continue;\r\n        }\r\n    }\r\n    return mergeLiteral(result);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}