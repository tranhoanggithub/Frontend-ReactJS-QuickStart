{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nexport default function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {\n  var debug = _ref.debug;\n  var newState = _extends({}, reducedState);\n  // only rehydrate if inboundState exists and is an object\n  if (inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') {\n    Object.keys(inboundState).forEach(function (key) {\n      // ignore _persist data\n      if (key === '_persist') return;\n      // if reducer modifies substate, skip auto rehydration\n      if (originalState[key] !== reducedState[key]) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\n        return;\n      }\n      if (isPlainEnoughObject(reducedState[key])) {\n        // if object is plain enough shallow merge the new values (hence \"Level2\")\n        newState[key] = _extends({}, newState[key], inboundState[key]);\n        return;\n      }\n      // otherwise hard set\n      newState[key] = inboundState[key];\n    });\n  }\n  if (process.env.NODE_ENV !== 'production' && debug && inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') console.log('redux-persist/stateReconciler: rehydrated keys \\'' + Object.keys(inboundState).join(', ') + '\\'');\n  return newState;\n}\n\n/*\n  autoMergeLevel2: \n    - merges 2 level of substate\n    - skips substate if already modified\n    - this is essentially redux-perist v4 behavior\n*/\n\nfunction isPlainEnoughObject(o) {\n  return o !== null && !Array.isArray(o) && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object';\n}","map":{"version":3,"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","autoMergeLevel2","inboundState","originalState","reducedState","_ref","debug","newState","keys","forEach","process","env","NODE_ENV","console","log","isPlainEnoughObject","join","o","Array","isArray"],"sources":["C:/Users/Admin/Desktop/LEARN REACTJS/Frontend-ReactJS-QuickStart/node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js"],"sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexport default function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {\n  var debug = _ref.debug;\n\n  var newState = _extends({}, reducedState);\n  // only rehydrate if inboundState exists and is an object\n  if (inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') {\n    Object.keys(inboundState).forEach(function (key) {\n      // ignore _persist data\n      if (key === '_persist') return;\n      // if reducer modifies substate, skip auto rehydration\n      if (originalState[key] !== reducedState[key]) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\n        return;\n      }\n      if (isPlainEnoughObject(reducedState[key])) {\n        // if object is plain enough shallow merge the new values (hence \"Level2\")\n        newState[key] = _extends({}, newState[key], inboundState[key]);\n        return;\n      }\n      // otherwise hard set\n      newState[key] = inboundState[key];\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production' && debug && inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') console.log('redux-persist/stateReconciler: rehydrated keys \\'' + Object.keys(inboundState).join(', ') + '\\'');\n\n  return newState;\n}\n\n/*\n  autoMergeLevel2: \n    - merges 2 level of substate\n    - skips substate if already modified\n    - this is essentially redux-perist v4 behavior\n*/\n\nfunction isPlainEnoughObject(o) {\n  return o !== null && !Array.isArray(o) && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object';\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}