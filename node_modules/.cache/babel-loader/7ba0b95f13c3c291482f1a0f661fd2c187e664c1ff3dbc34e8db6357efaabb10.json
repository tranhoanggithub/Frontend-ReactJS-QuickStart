{"ast":null,"code":"var _a;\nimport { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { SKELETON_TYPE, TYPE } from './types';\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton } from '@formatjs/icu-skeleton-parser';\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\" + SPACE_SEPARATOR_REGEX.source + \"*\");\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(SPACE_SEPARATOR_REGEX.source + \"*$\");\nfunction createLocation(start, end) {\n  return {\n    start: start,\n    end: end\n  };\n}\n// #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\nvar hasNativeStartsWith = !!String.prototype.startsWith;\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function (n) {\n  return typeof n === 'number' && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 0x1fffffffffffff;\n};\n// IE11 does not support y and u.\nvar REGEX_SUPPORTS_U_AND_Y = true;\ntry {\n  var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n  /**\r\n   * legacy Edge or Xbox One browser\r\n   * Unicode flag support: supported\r\n   * Pattern_Syntax support: not supported\r\n   * See https://github.com/formatjs/formatjs/issues/2822\r\n   */\n  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n} catch (_) {\n  REGEX_SUPPORTS_U_AND_Y = false;\n}\nvar startsWith = hasNativeStartsWith ?\n// Native\nfunction startsWith(s, search, position) {\n  return s.startsWith(search, position);\n} :\n// For IE11\nfunction startsWith(s, search, position) {\n  return s.slice(position, position + search.length) === search;\n};\nvar fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint :\n// IE11\nfunction fromCodePoint() {\n  var codePoints = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n  var elements = '';\n  var length = codePoints.length;\n  var i = 0;\n  var code;\n  while (length > i) {\n    code = codePoints[i++];\n    if (code > 0x10ffff) throw RangeError(code + ' is not a valid code point');\n    elements += code < 0x10000 ? String.fromCharCode(code) : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00);\n  }\n  return elements;\n};\nvar fromEntries =\n// native\nhasNativeFromEntries ? Object.fromEntries :\n// Ponyfill\nfunction fromEntries(entries) {\n  var obj = {};\n  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n    var _a = entries_1[_i],\n      k = _a[0],\n      v = _a[1];\n    obj[k] = v;\n  }\n  return obj;\n};\nvar codePointAt = hasNativeCodePointAt ?\n// Native\nfunction codePointAt(s, index) {\n  return s.codePointAt(index);\n} :\n// IE 11\nfunction codePointAt(s, index) {\n  var size = s.length;\n  if (index < 0 || index >= size) {\n    return undefined;\n  }\n  var first = s.charCodeAt(index);\n  var second;\n  return first < 0xd800 || first > 0xdbff || index + 1 === size || (second = s.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? first : (first - 0xd800 << 10) + (second - 0xdc00) + 0x10000;\n};\nvar trimStart = hasTrimStart ?\n// Native\nfunction trimStart(s) {\n  return s.trimStart();\n} :\n// Ponyfill\nfunction trimStart(s) {\n  return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n};\nvar trimEnd = hasTrimEnd ?\n// Native\nfunction trimEnd(s) {\n  return s.trimEnd();\n} :\n// Ponyfill\nfunction trimEnd(s) {\n  return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n};\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\nfunction RE(s, flag) {\n  return new RegExp(s, flag);\n}\n// #endregion\nvar matchIdentifierAtIndex;\nif (REGEX_SUPPORTS_U_AND_Y) {\n  // Native\n  var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var _a;\n    IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n    var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n    return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n  };\n} else {\n  // IE11\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var match = [];\n    while (true) {\n      var c = codePointAt(s, index);\n      if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n        break;\n      }\n      match.push(c);\n      index += c >= 0x10000 ? 2 : 1;\n    }\n    return fromCodePoint.apply(void 0, match);\n  };\n}\nvar Parser = /** @class */function () {\n  function Parser(message, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.message = message;\n    this.position = {\n      offset: 0,\n      line: 1,\n      column: 1\n    };\n    this.ignoreTag = !!options.ignoreTag;\n    this.requiresOtherClause = !!options.requiresOtherClause;\n    this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n  }\n  Parser.prototype.parse = function () {\n    if (this.offset() !== 0) {\n      throw Error('parser can only be used once');\n    }\n    return this.parseMessage(0, '', false);\n  };\n  Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n    var elements = [];\n    while (!this.isEOF()) {\n      var char = this.char();\n      if (char === 123 /* `{` */) {\n        var result = this.parseArgument(nestingLevel, expectingCloseTag);\n        if (result.err) {\n          return result;\n        }\n        elements.push(result.val);\n      } else if (char === 125 /* `}` */ && nestingLevel > 0) {\n        break;\n      } else if (char === 35 /* `#` */ && (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n        var position = this.clonePosition();\n        this.bump();\n        elements.push({\n          type: TYPE.pound,\n          location: createLocation(position, this.clonePosition())\n        });\n      } else if (char === 60 /* `<` */ && !this.ignoreTag && this.peek() === 47 // char code for '/'\n      ) {\n        if (expectingCloseTag) {\n          break;\n        } else {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n      } else if (char === 60 /* `<` */ && !this.ignoreTag && _isAlpha(this.peek() || 0)) {\n        var result = this.parseTag(nestingLevel, parentArgType);\n        if (result.err) {\n          return result;\n        }\n        elements.push(result.val);\n      } else {\n        var result = this.parseLiteral(nestingLevel, parentArgType);\n        if (result.err) {\n          return result;\n        }\n        elements.push(result.val);\n      }\n    }\n    return {\n      val: elements,\n      err: null\n    };\n  };\n  /**\r\n   * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\r\n   * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\r\n   * are accepted:\r\n   *\r\n   * ```\r\n   * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\r\n   * tagName ::= [a-z] (PENChar)*\r\n   * PENChar ::=\r\n   *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\r\n   *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\r\n   *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n   * ```\r\n   *\r\n   * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\r\n   * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\r\n   * since other tag-based engines like React allow it\r\n   */\n  Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n    var startPosition = this.clonePosition();\n    this.bump(); // `<`\n    var tagName = this.parseTagName();\n    this.bumpSpace();\n    if (this.bumpIf('/>')) {\n      // Self closing tag\n      return {\n        val: {\n          type: TYPE.literal,\n          value: \"<\" + tagName + \"/>\",\n          location: createLocation(startPosition, this.clonePosition())\n        },\n        err: null\n      };\n    } else if (this.bumpIf('>')) {\n      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n      if (childrenResult.err) {\n        return childrenResult;\n      }\n      var children = childrenResult.val;\n      // Expecting a close tag\n      var endTagStartPosition = this.clonePosition();\n      if (this.bumpIf('</')) {\n        if (this.isEOF() || !_isAlpha(this.char())) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n        var closingTagNameStartPosition = this.clonePosition();\n        var closingTagName = this.parseTagName();\n        if (tagName !== closingTagName) {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n        }\n        this.bumpSpace();\n        if (!this.bumpIf('>')) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n        return {\n          val: {\n            type: TYPE.tag,\n            value: tagName,\n            children: children,\n            location: createLocation(startPosition, this.clonePosition())\n          },\n          err: null\n        };\n      } else {\n        return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n      }\n    } else {\n      return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n    }\n  };\n  /**\r\n   * This method assumes that the caller has peeked ahead for the first tag character.\r\n   */\n  Parser.prototype.parseTagName = function () {\n    var startOffset = this.offset();\n    this.bump(); // the first tag name character\n    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n      this.bump();\n    }\n    return this.message.slice(startOffset, this.offset());\n  };\n  Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n    var start = this.clonePosition();\n    var value = '';\n    while (true) {\n      var parseQuoteResult = this.tryParseQuote(parentArgType);\n      if (parseQuoteResult) {\n        value += parseQuoteResult;\n        continue;\n      }\n      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n      if (parseUnquotedResult) {\n        value += parseUnquotedResult;\n        continue;\n      }\n      var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n      if (parseLeftAngleResult) {\n        value += parseLeftAngleResult;\n        continue;\n      }\n      break;\n    }\n    var location = createLocation(start, this.clonePosition());\n    return {\n      val: {\n        type: TYPE.literal,\n        value: value,\n        location: location\n      },\n      err: null\n    };\n  };\n  Parser.prototype.tryParseLeftAngleBracket = function () {\n    if (!this.isEOF() && this.char() === 60 /* `<` */ && (this.ignoreTag ||\n    // If at the opening tag or closing tag position, bail.\n    !_isAlphaOrSlash(this.peek() || 0))) {\n      this.bump(); // `<`\n      return '<';\n    }\n    return null;\n  };\n  /**\r\n   * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\r\n   * a character that requires quoting (that is, \"only where needed\"), and works the same in\r\n   * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\r\n   */\n  Parser.prototype.tryParseQuote = function (parentArgType) {\n    if (this.isEOF() || this.char() !== 39 /* `'` */) {\n      return null;\n    }\n    // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n    // Check if is valid escaped character\n    switch (this.peek()) {\n      case 39 /* `'` */:\n        // double quote, should return as a single quote.\n        this.bump();\n        this.bump();\n        return \"'\";\n      // '{', '<', '>', '}'\n      case 123:\n      case 60:\n      case 62:\n      case 125:\n        break;\n      case 35:\n        // '#'\n        if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n          break;\n        }\n        return null;\n      default:\n        return null;\n    }\n    this.bump(); // apostrophe\n    var codePoints = [this.char()]; // escaped char\n    this.bump();\n    // read chars until the optional closing apostrophe is found\n    while (!this.isEOF()) {\n      var ch = this.char();\n      if (ch === 39 /* `'` */) {\n        if (this.peek() === 39 /* `'` */) {\n          codePoints.push(39);\n          // Bump one more time because we need to skip 2 characters.\n          this.bump();\n        } else {\n          // Optional closing apostrophe.\n          this.bump();\n          break;\n        }\n      } else {\n        codePoints.push(ch);\n      }\n      this.bump();\n    }\n    return fromCodePoint.apply(void 0, codePoints);\n  };\n  Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n    if (this.isEOF()) {\n      return null;\n    }\n    var ch = this.char();\n    if (ch === 60 /* `<` */ || ch === 123 /* `{` */ || ch === 35 /* `#` */ && (parentArgType === 'plural' || parentArgType === 'selectordinal') || ch === 125 /* `}` */ && nestingLevel > 0) {\n      return null;\n    } else {\n      this.bump();\n      return fromCodePoint(ch);\n    }\n  };\n  Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n    var openingBracePosition = this.clonePosition();\n    this.bump(); // `{`\n    this.bumpSpace();\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    if (this.char() === 125 /* `}` */) {\n      this.bump();\n      return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    // argument name\n    var value = this.parseIdentifierIfPossible().value;\n    if (!value) {\n      return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    this.bumpSpace();\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    switch (this.char()) {\n      // Simple argument: `{name}`\n      case 125 /* `}` */:\n        {\n          this.bump(); // `}`\n          return {\n            val: {\n              type: TYPE.argument,\n              // value does not include the opening and closing braces.\n              value: value,\n              location: createLocation(openingBracePosition, this.clonePosition())\n            },\n            err: null\n          };\n        }\n      // Argument with options: `{name, format, ...}`\n      case 44 /* `,` */:\n        {\n          this.bump(); // `,`\n          this.bumpSpace();\n          if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n          }\n          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n        }\n      default:\n        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n  };\n  /**\r\n   * Advance the parser until the end of the identifier, if it is currently on\r\n   * an identifier character. Return an empty string otherwise.\r\n   */\n  Parser.prototype.parseIdentifierIfPossible = function () {\n    var startingPosition = this.clonePosition();\n    var startOffset = this.offset();\n    var value = matchIdentifierAtIndex(this.message, startOffset);\n    var endOffset = startOffset + value.length;\n    this.bumpTo(endOffset);\n    var endPosition = this.clonePosition();\n    var location = createLocation(startingPosition, endPosition);\n    return {\n      value: value,\n      location: location\n    };\n  };\n  Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n    var _a;\n    // Parse this range:\n    // {name, type, style}\n    //        ^---^\n    var typeStartPosition = this.clonePosition();\n    var argType = this.parseIdentifierIfPossible().value;\n    var typeEndPosition = this.clonePosition();\n    switch (argType) {\n      case '':\n        // Expecting a style string number, date, time, plural, selectordinal, or select.\n        return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n      case 'number':\n      case 'date':\n      case 'time':\n        {\n          // Parse this range:\n          // {name, number, style}\n          //              ^-------^\n          this.bumpSpace();\n          var styleAndLocation = null;\n          if (this.bumpIf(',')) {\n            this.bumpSpace();\n            var styleStartPosition = this.clonePosition();\n            var result = this.parseSimpleArgStyleIfPossible();\n            if (result.err) {\n              return result;\n            }\n            var style = trimEnd(result.val);\n            if (style.length === 0) {\n              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n            var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n            styleAndLocation = {\n              style: style,\n              styleLocation: styleLocation\n            };\n          }\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n          var location_1 = createLocation(openingBracePosition, this.clonePosition());\n          // Extract style or skeleton\n          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n            // Skeleton starts with `::`.\n            var skeleton = trimStart(styleAndLocation.style.slice(2));\n            if (argType === 'number') {\n              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n              if (result.err) {\n                return result;\n              }\n              return {\n                val: {\n                  type: TYPE.number,\n                  value: value,\n                  location: location_1,\n                  style: result.val\n                },\n                err: null\n              };\n            } else {\n              if (skeleton.length === 0) {\n                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n              }\n              var style = {\n                type: SKELETON_TYPE.dateTime,\n                pattern: skeleton,\n                location: styleAndLocation.styleLocation,\n                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(skeleton) : {}\n              };\n              var type = argType === 'date' ? TYPE.date : TYPE.time;\n              return {\n                val: {\n                  type: type,\n                  value: value,\n                  location: location_1,\n                  style: style\n                },\n                err: null\n              };\n            }\n          }\n          // Regular style or no style.\n          return {\n            val: {\n              type: argType === 'number' ? TYPE.number : argType === 'date' ? TYPE.date : TYPE.time,\n              value: value,\n              location: location_1,\n              style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null\n            },\n            err: null\n          };\n        }\n      case 'plural':\n      case 'selectordinal':\n      case 'select':\n        {\n          // Parse this range:\n          // {name, plural, options}\n          //              ^---------^\n          var typeEndPosition_1 = this.clonePosition();\n          this.bumpSpace();\n          if (!this.bumpIf(',')) {\n            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\n          }\n          this.bumpSpace();\n          // Parse offset:\n          // {name, plural, offset:1, options}\n          //                ^-----^\n          //\n          // or the first option:\n          //\n          // {name, plural, one {...} other {...}}\n          //                ^--^\n          var identifierAndLocation = this.parseIdentifierIfPossible();\n          var pluralOffset = 0;\n          if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n            if (!this.bumpIf(':')) {\n              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n            this.bumpSpace();\n            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n            if (result.err) {\n              return result;\n            }\n            // Parse another identifier for option parsing\n            this.bumpSpace();\n            identifierAndLocation = this.parseIdentifierIfPossible();\n            pluralOffset = result.val;\n          }\n          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n          if (optionsResult.err) {\n            return optionsResult;\n          }\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n          var location_2 = createLocation(openingBracePosition, this.clonePosition());\n          if (argType === 'select') {\n            return {\n              val: {\n                type: TYPE.select,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                location: location_2\n              },\n              err: null\n            };\n          } else {\n            return {\n              val: {\n                type: TYPE.plural,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                offset: pluralOffset,\n                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                location: location_2\n              },\n              err: null\n            };\n          }\n        }\n      default:\n        return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n    }\n  };\n  Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n    // Parse: {value, number, ::currency/GBP }\n    //\n    if (this.isEOF() || this.char() !== 125 /* `}` */) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    this.bump(); // `}`\n    return {\n      val: true,\n      err: null\n    };\n  };\n  /**\r\n   * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\r\n   */\n  Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n    var nestedBraces = 0;\n    var startPosition = this.clonePosition();\n    while (!this.isEOF()) {\n      var ch = this.char();\n      switch (ch) {\n        case 39 /* `'` */:\n          {\n            // Treat apostrophe as quoting but include it in the style part.\n            // Find the end of the quoted literal text.\n            this.bump();\n            var apostrophePosition = this.clonePosition();\n            if (!this.bumpUntil(\"'\")) {\n              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n            }\n            this.bump();\n            break;\n          }\n        case 123 /* `{` */:\n          {\n            nestedBraces += 1;\n            this.bump();\n            break;\n          }\n        case 125 /* `}` */:\n          {\n            if (nestedBraces > 0) {\n              nestedBraces -= 1;\n            } else {\n              return {\n                val: this.message.slice(startPosition.offset, this.offset()),\n                err: null\n              };\n            }\n            break;\n          }\n        default:\n          this.bump();\n          break;\n      }\n    }\n    return {\n      val: this.message.slice(startPosition.offset, this.offset()),\n      err: null\n    };\n  };\n  Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n    var tokens = [];\n    try {\n      tokens = parseNumberSkeletonFromString(skeleton);\n    } catch (e) {\n      return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\n    }\n    return {\n      val: {\n        type: SKELETON_TYPE.number,\n        tokens: tokens,\n        location: location,\n        parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}\n      },\n      err: null\n    };\n  };\n  /**\r\n   * @param nesting_level The current nesting level of messages.\r\n   *     This can be positive when parsing message fragment in select or plural argument options.\r\n   * @param parent_arg_type The parent argument's type.\r\n   * @param parsed_first_identifier If provided, this is the first identifier-like selector of\r\n   *     the argument. It is a by-product of a previous parsing attempt.\r\n   * @param expecting_close_tag If true, this message is directly or indirectly nested inside\r\n   *     between a pair of opening and closing tags. The nested message will not parse beyond\r\n   *     the closing tag boundary.\r\n   */\n  Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n    var _a;\n    var hasOtherClause = false;\n    var options = [];\n    var parsedSelectors = new Set();\n    var selector = parsedFirstIdentifier.value,\n      selectorLocation = parsedFirstIdentifier.location;\n    // Parse:\n    // one {one apple}\n    // ^--^\n    while (true) {\n      if (selector.length === 0) {\n        var startPosition = this.clonePosition();\n        if (parentArgType !== 'select' && this.bumpIf('=')) {\n          // Try parse `={number}` selector\n          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n          if (result.err) {\n            return result;\n          }\n          selectorLocation = createLocation(startPosition, this.clonePosition());\n          selector = this.message.slice(startPosition.offset, this.offset());\n        } else {\n          break;\n        }\n      }\n      // Duplicate selector clauses\n      if (parsedSelectors.has(selector)) {\n        return this.error(parentArgType === 'select' ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n      }\n      if (selector === 'other') {\n        hasOtherClause = true;\n      }\n      // Parse:\n      // one {one apple}\n      //     ^----------^\n      this.bumpSpace();\n      var openingBracePosition = this.clonePosition();\n      if (!this.bumpIf('{')) {\n        return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n      }\n      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n      if (fragmentResult.err) {\n        return fragmentResult;\n      }\n      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n      if (argCloseResult.err) {\n        return argCloseResult;\n      }\n      options.push([selector, {\n        value: fragmentResult.val,\n        location: createLocation(openingBracePosition, this.clonePosition())\n      }]);\n      // Keep track of the existing selectors\n      parsedSelectors.add(selector);\n      // Prep next selector clause.\n      this.bumpSpace();\n      _a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location;\n    }\n    if (options.length === 0) {\n      return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n    if (this.requiresOtherClause && !hasOtherClause) {\n      return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n    return {\n      val: options,\n      err: null\n    };\n  };\n  Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n    var sign = 1;\n    var startingPosition = this.clonePosition();\n    if (this.bumpIf('+')) {} else if (this.bumpIf('-')) {\n      sign = -1;\n    }\n    var hasDigits = false;\n    var decimal = 0;\n    while (!this.isEOF()) {\n      var ch = this.char();\n      if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\n        hasDigits = true;\n        decimal = decimal * 10 + (ch - 48);\n        this.bump();\n      } else {\n        break;\n      }\n    }\n    var location = createLocation(startingPosition, this.clonePosition());\n    if (!hasDigits) {\n      return this.error(expectNumberError, location);\n    }\n    decimal *= sign;\n    if (!isSafeInteger(decimal)) {\n      return this.error(invalidNumberError, location);\n    }\n    return {\n      val: decimal,\n      err: null\n    };\n  };\n  Parser.prototype.offset = function () {\n    return this.position.offset;\n  };\n  Parser.prototype.isEOF = function () {\n    return this.offset() === this.message.length;\n  };\n  Parser.prototype.clonePosition = function () {\n    // This is much faster than `Object.assign` or spread.\n    return {\n      offset: this.position.offset,\n      line: this.position.line,\n      column: this.position.column\n    };\n  };\n  /**\r\n   * Return the code point at the current position of the parser.\r\n   * Throws if the index is out of bound.\r\n   */\n  Parser.prototype.char = function () {\n    var offset = this.position.offset;\n    if (offset >= this.message.length) {\n      throw Error('out of bound');\n    }\n    var code = codePointAt(this.message, offset);\n    if (code === undefined) {\n      throw Error(\"Offset \" + offset + \" is at invalid UTF-16 code unit boundary\");\n    }\n    return code;\n  };\n  Parser.prototype.error = function (kind, location) {\n    return {\n      val: null,\n      err: {\n        kind: kind,\n        message: this.message,\n        location: location\n      }\n    };\n  };\n  /** Bump the parser to the next UTF-16 code unit. */\n  Parser.prototype.bump = function () {\n    if (this.isEOF()) {\n      return;\n    }\n    var code = this.char();\n    if (code === 10 /* '\\n' */) {\n      this.position.line += 1;\n      this.position.column = 1;\n      this.position.offset += 1;\n    } else {\n      this.position.column += 1;\n      // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n      this.position.offset += code < 0x10000 ? 1 : 2;\n    }\n  };\n  /**\r\n   * If the substring starting at the current position of the parser has\r\n   * the given prefix, then bump the parser to the character immediately\r\n   * following the prefix and return true. Otherwise, don't bump the parser\r\n   * and return false.\r\n   */\n  Parser.prototype.bumpIf = function (prefix) {\n    if (startsWith(this.message, prefix, this.offset())) {\n      for (var i = 0; i < prefix.length; i++) {\n        this.bump();\n      }\n      return true;\n    }\n    return false;\n  };\n  /**\r\n   * Bump the parser until the pattern character is found and return `true`.\r\n   * Otherwise bump to the end of the file and return `false`.\r\n   */\n  Parser.prototype.bumpUntil = function (pattern) {\n    var currentOffset = this.offset();\n    var index = this.message.indexOf(pattern, currentOffset);\n    if (index >= 0) {\n      this.bumpTo(index);\n      return true;\n    } else {\n      this.bumpTo(this.message.length);\n      return false;\n    }\n  };\n  /**\r\n   * Bump the parser to the target offset.\r\n   * If target offset is beyond the end of the input, bump the parser to the end of the input.\r\n   */\n  Parser.prototype.bumpTo = function (targetOffset) {\n    if (this.offset() > targetOffset) {\n      throw Error(\"targetOffset \" + targetOffset + \" must be greater than or equal to the current offset \" + this.offset());\n    }\n    targetOffset = Math.min(targetOffset, this.message.length);\n    while (true) {\n      var offset = this.offset();\n      if (offset === targetOffset) {\n        break;\n      }\n      if (offset > targetOffset) {\n        throw Error(\"targetOffset \" + targetOffset + \" is at invalid UTF-16 code unit boundary\");\n      }\n      this.bump();\n      if (this.isEOF()) {\n        break;\n      }\n    }\n  };\n  /** advance the parser through all whitespace to the next non-whitespace code unit. */\n  Parser.prototype.bumpSpace = function () {\n    while (!this.isEOF() && _isWhiteSpace(this.char())) {\n      this.bump();\n    }\n  };\n  /**\r\n   * Peek at the *next* Unicode codepoint in the input without advancing the parser.\r\n   * If the input has been exhausted, then this returns null.\r\n   */\n  Parser.prototype.peek = function () {\n    if (this.isEOF()) {\n      return null;\n    }\n    var code = this.char();\n    var offset = this.offset();\n    var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n    return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n  };\n  return Parser;\n}();\nexport { Parser };\n/**\r\n * This check if codepoint is alphabet (lower & uppercase)\r\n * @param codepoint\r\n * @returns\r\n */\nfunction _isAlpha(codepoint) {\n  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;\n}\nfunction _isAlphaOrSlash(codepoint) {\n  return _isAlpha(codepoint) || codepoint === 47; /* '/' */\n}\n/** See `parseTag` function docs. */\nfunction _isPotentialElementNameChar(c) {\n  return c === 45 /* '-' */ || c === 46 /* '.' */ || c >= 48 && c <= 57 /* 0..9 */ || c === 95 /* '_' */ || c >= 97 && c <= 122 /** a..z */ || c >= 65 && c <= 90 /* A..Z */ || c == 0xb7 || c >= 0xc0 && c <= 0xd6 || c >= 0xd8 && c <= 0xf6 || c >= 0xf8 && c <= 0x37d || c >= 0x37f && c <= 0x1fff || c >= 0x200c && c <= 0x200d || c >= 0x203f && c <= 0x2040 || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff || c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;\n}\n/**\r\n * Code point equivalent of regex `\\p{White_Space}`.\r\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\nfunction _isWhiteSpace(c) {\n  return c >= 0x0009 && c <= 0x000d || c === 0x0020 || c === 0x0085 || c >= 0x200e && c <= 0x200f || c === 0x2028 || c === 0x2029;\n}\n/**\r\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\r\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\nfunction _isPatternSyntax(c) {\n  return c >= 0x0021 && c <= 0x0023 || c === 0x0024 || c >= 0x0025 && c <= 0x0027 || c === 0x0028 || c === 0x0029 || c === 0x002a || c === 0x002b || c === 0x002c || c === 0x002d || c >= 0x002e && c <= 0x002f || c >= 0x003a && c <= 0x003b || c >= 0x003c && c <= 0x003e || c >= 0x003f && c <= 0x0040 || c === 0x005b || c === 0x005c || c === 0x005d || c === 0x005e || c === 0x0060 || c === 0x007b || c === 0x007c || c === 0x007d || c === 0x007e || c === 0x00a1 || c >= 0x00a2 && c <= 0x00a5 || c === 0x00a6 || c === 0x00a7 || c === 0x00a9 || c === 0x00ab || c === 0x00ac || c === 0x00ae || c === 0x00b0 || c === 0x00b1 || c === 0x00b6 || c === 0x00bb || c === 0x00bf || c === 0x00d7 || c === 0x00f7 || c >= 0x2010 && c <= 0x2015 || c >= 0x2016 && c <= 0x2017 || c === 0x2018 || c === 0x2019 || c === 0x201a || c >= 0x201b && c <= 0x201c || c === 0x201d || c === 0x201e || c === 0x201f || c >= 0x2020 && c <= 0x2027 || c >= 0x2030 && c <= 0x2038 || c === 0x2039 || c === 0x203a || c >= 0x203b && c <= 0x203e || c >= 0x2041 && c <= 0x2043 || c === 0x2044 || c === 0x2045 || c === 0x2046 || c >= 0x2047 && c <= 0x2051 || c === 0x2052 || c === 0x2053 || c >= 0x2055 && c <= 0x205e || c >= 0x2190 && c <= 0x2194 || c >= 0x2195 && c <= 0x2199 || c >= 0x219a && c <= 0x219b || c >= 0x219c && c <= 0x219f || c === 0x21a0 || c >= 0x21a1 && c <= 0x21a2 || c === 0x21a3 || c >= 0x21a4 && c <= 0x21a5 || c === 0x21a6 || c >= 0x21a7 && c <= 0x21ad || c === 0x21ae || c >= 0x21af && c <= 0x21cd || c >= 0x21ce && c <= 0x21cf || c >= 0x21d0 && c <= 0x21d1 || c === 0x21d2 || c === 0x21d3 || c === 0x21d4 || c >= 0x21d5 && c <= 0x21f3 || c >= 0x21f4 && c <= 0x22ff || c >= 0x2300 && c <= 0x2307 || c === 0x2308 || c === 0x2309 || c === 0x230a || c === 0x230b || c >= 0x230c && c <= 0x231f || c >= 0x2320 && c <= 0x2321 || c >= 0x2322 && c <= 0x2328 || c === 0x2329 || c === 0x232a || c >= 0x232b && c <= 0x237b || c === 0x237c || c >= 0x237d && c <= 0x239a || c >= 0x239b && c <= 0x23b3 || c >= 0x23b4 && c <= 0x23db || c >= 0x23dc && c <= 0x23e1 || c >= 0x23e2 && c <= 0x2426 || c >= 0x2427 && c <= 0x243f || c >= 0x2440 && c <= 0x244a || c >= 0x244b && c <= 0x245f || c >= 0x2500 && c <= 0x25b6 || c === 0x25b7 || c >= 0x25b8 && c <= 0x25c0 || c === 0x25c1 || c >= 0x25c2 && c <= 0x25f7 || c >= 0x25f8 && c <= 0x25ff || c >= 0x2600 && c <= 0x266e || c === 0x266f || c >= 0x2670 && c <= 0x2767 || c === 0x2768 || c === 0x2769 || c === 0x276a || c === 0x276b || c === 0x276c || c === 0x276d || c === 0x276e || c === 0x276f || c === 0x2770 || c === 0x2771 || c === 0x2772 || c === 0x2773 || c === 0x2774 || c === 0x2775 || c >= 0x2794 && c <= 0x27bf || c >= 0x27c0 && c <= 0x27c4 || c === 0x27c5 || c === 0x27c6 || c >= 0x27c7 && c <= 0x27e5 || c === 0x27e6 || c === 0x27e7 || c === 0x27e8 || c === 0x27e9 || c === 0x27ea || c === 0x27eb || c === 0x27ec || c === 0x27ed || c === 0x27ee || c === 0x27ef || c >= 0x27f0 && c <= 0x27ff || c >= 0x2800 && c <= 0x28ff || c >= 0x2900 && c <= 0x2982 || c === 0x2983 || c === 0x2984 || c === 0x2985 || c === 0x2986 || c === 0x2987 || c === 0x2988 || c === 0x2989 || c === 0x298a || c === 0x298b || c === 0x298c || c === 0x298d || c === 0x298e || c === 0x298f || c === 0x2990 || c === 0x2991 || c === 0x2992 || c === 0x2993 || c === 0x2994 || c === 0x2995 || c === 0x2996 || c === 0x2997 || c === 0x2998 || c >= 0x2999 && c <= 0x29d7 || c === 0x29d8 || c === 0x29d9 || c === 0x29da || c === 0x29db || c >= 0x29dc && c <= 0x29fb || c === 0x29fc || c === 0x29fd || c >= 0x29fe && c <= 0x2aff || c >= 0x2b00 && c <= 0x2b2f || c >= 0x2b30 && c <= 0x2b44 || c >= 0x2b45 && c <= 0x2b46 || c >= 0x2b47 && c <= 0x2b4c || c >= 0x2b4d && c <= 0x2b73 || c >= 0x2b74 && c <= 0x2b75 || c >= 0x2b76 && c <= 0x2b95 || c === 0x2b96 || c >= 0x2b97 && c <= 0x2bff || c >= 0x2e00 && c <= 0x2e01 || c === 0x2e02 || c === 0x2e03 || c === 0x2e04 || c === 0x2e05 || c >= 0x2e06 && c <= 0x2e08 || c === 0x2e09 || c === 0x2e0a || c === 0x2e0b || c === 0x2e0c || c === 0x2e0d || c >= 0x2e0e && c <= 0x2e16 || c === 0x2e17 || c >= 0x2e18 && c <= 0x2e19 || c === 0x2e1a || c === 0x2e1b || c === 0x2e1c || c === 0x2e1d || c >= 0x2e1e && c <= 0x2e1f || c === 0x2e20 || c === 0x2e21 || c === 0x2e22 || c === 0x2e23 || c === 0x2e24 || c === 0x2e25 || c === 0x2e26 || c === 0x2e27 || c === 0x2e28 || c === 0x2e29 || c >= 0x2e2a && c <= 0x2e2e || c === 0x2e2f || c >= 0x2e30 && c <= 0x2e39 || c >= 0x2e3a && c <= 0x2e3b || c >= 0x2e3c && c <= 0x2e3f || c === 0x2e40 || c === 0x2e41 || c === 0x2e42 || c >= 0x2e43 && c <= 0x2e4f || c >= 0x2e50 && c <= 0x2e51 || c === 0x2e52 || c >= 0x2e53 && c <= 0x2e7f || c >= 0x3001 && c <= 0x3003 || c === 0x3008 || c === 0x3009 || c === 0x300a || c === 0x300b || c === 0x300c || c === 0x300d || c === 0x300e || c === 0x300f || c === 0x3010 || c === 0x3011 || c >= 0x3012 && c <= 0x3013 || c === 0x3014 || c === 0x3015 || c === 0x3016 || c === 0x3017 || c === 0x3018 || c === 0x3019 || c === 0x301a || c === 0x301b || c === 0x301c || c === 0x301d || c >= 0x301e && c <= 0x301f || c === 0x3020 || c === 0x3030 || c === 0xfd3e || c === 0xfd3f || c >= 0xfe45 && c <= 0xfe46;\n}","map":{"version":3,"names":["_a","__assign","ErrorKind","SKELETON_TYPE","TYPE","SPACE_SEPARATOR_REGEX","parseNumberSkeleton","parseNumberSkeletonFromString","parseDateTimeSkeleton","SPACE_SEPARATOR_START_REGEX","RegExp","source","SPACE_SEPARATOR_END_REGEX","createLocation","start","end","hasNativeStartsWith","String","prototype","startsWith","hasNativeFromCodePoint","fromCodePoint","hasNativeFromEntries","Object","fromEntries","hasNativeCodePointAt","codePointAt","hasTrimStart","trimStart","hasTrimEnd","trimEnd","hasNativeIsSafeInteger","Number","isSafeInteger","n","isFinite","Math","floor","abs","REGEX_SUPPORTS_U_AND_Y","re","RE","exec","_","s","search","position","slice","length","codePoints","_i","arguments","elements","i","code","RangeError","fromCharCode","entries","obj","entries_1","k","v","index","size","undefined","first","charCodeAt","second","replace","flag","matchIdentifierAtIndex","IDENTIFIER_PREFIX_RE_1","lastIndex","match","c","_isWhiteSpace","_isPatternSyntax","push","apply","Parser","message","options","offset","line","column","ignoreTag","requiresOtherClause","shouldParseSkeletons","parse","Error","parseMessage","nestingLevel","parentArgType","expectingCloseTag","isEOF","char","result","parseArgument","err","val","clonePosition","bump","type","pound","location","peek","error","UNMATCHED_CLOSING_TAG","_isAlpha","parseTag","parseLiteral","startPosition","tagName","parseTagName","bumpSpace","bumpIf","literal","value","childrenResult","children","endTagStartPosition","INVALID_TAG","closingTagNameStartPosition","closingTagName","tag","UNCLOSED_TAG","startOffset","_isPotentialElementNameChar","parseQuoteResult","tryParseQuote","parseUnquotedResult","tryParseUnquoted","parseLeftAngleResult","tryParseLeftAngleBracket","_isAlphaOrSlash","ch","openingBracePosition","EXPECT_ARGUMENT_CLOSING_BRACE","EMPTY_ARGUMENT","parseIdentifierIfPossible","MALFORMED_ARGUMENT","argument","parseArgumentOptions","startingPosition","endOffset","bumpTo","endPosition","typeStartPosition","argType","typeEndPosition","EXPECT_ARGUMENT_TYPE","styleAndLocation","styleStartPosition","parseSimpleArgStyleIfPossible","style","EXPECT_ARGUMENT_STYLE","styleLocation","argCloseResult","tryParseArgumentClose","location_1","skeleton","number","EXPECT_DATE_TIME_SKELETON","dateTime","pattern","parsedOptions","date","time","typeEndPosition_1","EXPECT_SELECT_ARGUMENT_OPTIONS","identifierAndLocation","pluralOffset","EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE","tryParseDecimalInteger","INVALID_PLURAL_ARGUMENT_OFFSET_VALUE","optionsResult","tryParsePluralOrSelectOptions","location_2","select","plural","pluralType","INVALID_ARGUMENT_TYPE","nestedBraces","apostrophePosition","bumpUntil","UNCLOSED_QUOTE_IN_ARGUMENT_STYLE","tokens","e","INVALID_NUMBER_SKELETON","expectCloseTag","parsedFirstIdentifier","hasOtherClause","parsedSelectors","Set","selector","selectorLocation","EXPECT_PLURAL_ARGUMENT_SELECTOR","INVALID_PLURAL_ARGUMENT_SELECTOR","has","DUPLICATE_SELECT_ARGUMENT_SELECTOR","DUPLICATE_PLURAL_ARGUMENT_SELECTOR","EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT","EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT","fragmentResult","add","EXPECT_SELECT_ARGUMENT_SELECTOR","MISSING_OTHER_CLAUSE","expectNumberError","invalidNumberError","sign","hasDigits","decimal","kind","prefix","currentOffset","indexOf","targetOffset","min","nextCode","codepoint"],"sources":["C:/Users/Admin/Desktop/LEARN REACTJS/Frontend-ReactJS-QuickStart/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js"],"sourcesContent":["var _a;\r\nimport { __assign } from \"tslib\";\r\nimport { ErrorKind } from './error';\r\nimport { SKELETON_TYPE, TYPE, } from './types';\r\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\r\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton, } from '@formatjs/icu-skeleton-parser';\r\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\" + SPACE_SEPARATOR_REGEX.source + \"*\");\r\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(SPACE_SEPARATOR_REGEX.source + \"*$\");\r\nfunction createLocation(start, end) {\r\n    return { start: start, end: end };\r\n}\r\n// #region Ponyfills\r\n// Consolidate these variables up top for easier toggling during debugging\r\nvar hasNativeStartsWith = !!String.prototype.startsWith;\r\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\r\nvar hasNativeFromEntries = !!Object.fromEntries;\r\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\r\nvar hasTrimStart = !!String.prototype.trimStart;\r\nvar hasTrimEnd = !!String.prototype.trimEnd;\r\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\r\nvar isSafeInteger = hasNativeIsSafeInteger\r\n    ? Number.isSafeInteger\r\n    : function (n) {\r\n        return (typeof n === 'number' &&\r\n            isFinite(n) &&\r\n            Math.floor(n) === n &&\r\n            Math.abs(n) <= 0x1fffffffffffff);\r\n    };\r\n// IE11 does not support y and u.\r\nvar REGEX_SUPPORTS_U_AND_Y = true;\r\ntry {\r\n    var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\r\n    /**\r\n     * legacy Edge or Xbox One browser\r\n     * Unicode flag support: supported\r\n     * Pattern_Syntax support: not supported\r\n     * See https://github.com/formatjs/formatjs/issues/2822\r\n     */\r\n    REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\r\n}\r\ncatch (_) {\r\n    REGEX_SUPPORTS_U_AND_Y = false;\r\n}\r\nvar startsWith = hasNativeStartsWith\r\n    ? // Native\r\n        function startsWith(s, search, position) {\r\n            return s.startsWith(search, position);\r\n        }\r\n    : // For IE11\r\n        function startsWith(s, search, position) {\r\n            return s.slice(position, position + search.length) === search;\r\n        };\r\nvar fromCodePoint = hasNativeFromCodePoint\r\n    ? String.fromCodePoint\r\n    : // IE11\r\n        function fromCodePoint() {\r\n            var codePoints = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                codePoints[_i] = arguments[_i];\r\n            }\r\n            var elements = '';\r\n            var length = codePoints.length;\r\n            var i = 0;\r\n            var code;\r\n            while (length > i) {\r\n                code = codePoints[i++];\r\n                if (code > 0x10ffff)\r\n                    throw RangeError(code + ' is not a valid code point');\r\n                elements +=\r\n                    code < 0x10000\r\n                        ? String.fromCharCode(code)\r\n                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);\r\n            }\r\n            return elements;\r\n        };\r\nvar fromEntries = \r\n// native\r\nhasNativeFromEntries\r\n    ? Object.fromEntries\r\n    : // Ponyfill\r\n        function fromEntries(entries) {\r\n            var obj = {};\r\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\r\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\r\n                obj[k] = v;\r\n            }\r\n            return obj;\r\n        };\r\nvar codePointAt = hasNativeCodePointAt\r\n    ? // Native\r\n        function codePointAt(s, index) {\r\n            return s.codePointAt(index);\r\n        }\r\n    : // IE 11\r\n        function codePointAt(s, index) {\r\n            var size = s.length;\r\n            if (index < 0 || index >= size) {\r\n                return undefined;\r\n            }\r\n            var first = s.charCodeAt(index);\r\n            var second;\r\n            return first < 0xd800 ||\r\n                first > 0xdbff ||\r\n                index + 1 === size ||\r\n                (second = s.charCodeAt(index + 1)) < 0xdc00 ||\r\n                second > 0xdfff\r\n                ? first\r\n                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;\r\n        };\r\nvar trimStart = hasTrimStart\r\n    ? // Native\r\n        function trimStart(s) {\r\n            return s.trimStart();\r\n        }\r\n    : // Ponyfill\r\n        function trimStart(s) {\r\n            return s.replace(SPACE_SEPARATOR_START_REGEX, '');\r\n        };\r\nvar trimEnd = hasTrimEnd\r\n    ? // Native\r\n        function trimEnd(s) {\r\n            return s.trimEnd();\r\n        }\r\n    : // Ponyfill\r\n        function trimEnd(s) {\r\n            return s.replace(SPACE_SEPARATOR_END_REGEX, '');\r\n        };\r\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\r\nfunction RE(s, flag) {\r\n    return new RegExp(s, flag);\r\n}\r\n// #endregion\r\nvar matchIdentifierAtIndex;\r\nif (REGEX_SUPPORTS_U_AND_Y) {\r\n    // Native\r\n    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\r\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\r\n        var _a;\r\n        IDENTIFIER_PREFIX_RE_1.lastIndex = index;\r\n        var match = IDENTIFIER_PREFIX_RE_1.exec(s);\r\n        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\r\n    };\r\n}\r\nelse {\r\n    // IE11\r\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\r\n        var match = [];\r\n        while (true) {\r\n            var c = codePointAt(s, index);\r\n            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\r\n                break;\r\n            }\r\n            match.push(c);\r\n            index += c >= 0x10000 ? 2 : 1;\r\n        }\r\n        return fromCodePoint.apply(void 0, match);\r\n    };\r\n}\r\nvar Parser = /** @class */ (function () {\r\n    function Parser(message, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.message = message;\r\n        this.position = { offset: 0, line: 1, column: 1 };\r\n        this.ignoreTag = !!options.ignoreTag;\r\n        this.requiresOtherClause = !!options.requiresOtherClause;\r\n        this.shouldParseSkeletons = !!options.shouldParseSkeletons;\r\n    }\r\n    Parser.prototype.parse = function () {\r\n        if (this.offset() !== 0) {\r\n            throw Error('parser can only be used once');\r\n        }\r\n        return this.parseMessage(0, '', false);\r\n    };\r\n    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\r\n        var elements = [];\r\n        while (!this.isEOF()) {\r\n            var char = this.char();\r\n            if (char === 123 /* `{` */) {\r\n                var result = this.parseArgument(nestingLevel, expectingCloseTag);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n            else if (char === 125 /* `}` */ && nestingLevel > 0) {\r\n                break;\r\n            }\r\n            else if (char === 35 /* `#` */ &&\r\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\r\n                var position = this.clonePosition();\r\n                this.bump();\r\n                elements.push({\r\n                    type: TYPE.pound,\r\n                    location: createLocation(position, this.clonePosition()),\r\n                });\r\n            }\r\n            else if (char === 60 /* `<` */ &&\r\n                !this.ignoreTag &&\r\n                this.peek() === 47 // char code for '/'\r\n            ) {\r\n                if (expectingCloseTag) {\r\n                    break;\r\n                }\r\n                else {\r\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\r\n                }\r\n            }\r\n            else if (char === 60 /* `<` */ &&\r\n                !this.ignoreTag &&\r\n                _isAlpha(this.peek() || 0)) {\r\n                var result = this.parseTag(nestingLevel, parentArgType);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n            else {\r\n                var result = this.parseLiteral(nestingLevel, parentArgType);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n        }\r\n        return { val: elements, err: null };\r\n    };\r\n    /**\r\n     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\r\n     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\r\n     * are accepted:\r\n     *\r\n     * ```\r\n     * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\r\n     * tagName ::= [a-z] (PENChar)*\r\n     * PENChar ::=\r\n     *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\r\n     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\r\n     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n     * ```\r\n     *\r\n     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\r\n     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\r\n     * since other tag-based engines like React allow it\r\n     */\r\n    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\r\n        var startPosition = this.clonePosition();\r\n        this.bump(); // `<`\r\n        var tagName = this.parseTagName();\r\n        this.bumpSpace();\r\n        if (this.bumpIf('/>')) {\r\n            // Self closing tag\r\n            return {\r\n                val: {\r\n                    type: TYPE.literal,\r\n                    value: \"<\" + tagName + \"/>\",\r\n                    location: createLocation(startPosition, this.clonePosition()),\r\n                },\r\n                err: null,\r\n            };\r\n        }\r\n        else if (this.bumpIf('>')) {\r\n            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\r\n            if (childrenResult.err) {\r\n                return childrenResult;\r\n            }\r\n            var children = childrenResult.val;\r\n            // Expecting a close tag\r\n            var endTagStartPosition = this.clonePosition();\r\n            if (this.bumpIf('</')) {\r\n                if (this.isEOF() || !_isAlpha(this.char())) {\r\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\r\n                }\r\n                var closingTagNameStartPosition = this.clonePosition();\r\n                var closingTagName = this.parseTagName();\r\n                if (tagName !== closingTagName) {\r\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\r\n                }\r\n                this.bumpSpace();\r\n                if (!this.bumpIf('>')) {\r\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\r\n                }\r\n                return {\r\n                    val: {\r\n                        type: TYPE.tag,\r\n                        value: tagName,\r\n                        children: children,\r\n                        location: createLocation(startPosition, this.clonePosition()),\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            else {\r\n                return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\r\n            }\r\n        }\r\n        else {\r\n            return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\r\n        }\r\n    };\r\n    /**\r\n     * This method assumes that the caller has peeked ahead for the first tag character.\r\n     */\r\n    Parser.prototype.parseTagName = function () {\r\n        var startOffset = this.offset();\r\n        this.bump(); // the first tag name character\r\n        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\r\n            this.bump();\r\n        }\r\n        return this.message.slice(startOffset, this.offset());\r\n    };\r\n    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\r\n        var start = this.clonePosition();\r\n        var value = '';\r\n        while (true) {\r\n            var parseQuoteResult = this.tryParseQuote(parentArgType);\r\n            if (parseQuoteResult) {\r\n                value += parseQuoteResult;\r\n                continue;\r\n            }\r\n            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\r\n            if (parseUnquotedResult) {\r\n                value += parseUnquotedResult;\r\n                continue;\r\n            }\r\n            var parseLeftAngleResult = this.tryParseLeftAngleBracket();\r\n            if (parseLeftAngleResult) {\r\n                value += parseLeftAngleResult;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        var location = createLocation(start, this.clonePosition());\r\n        return {\r\n            val: { type: TYPE.literal, value: value, location: location },\r\n            err: null,\r\n        };\r\n    };\r\n    Parser.prototype.tryParseLeftAngleBracket = function () {\r\n        if (!this.isEOF() &&\r\n            this.char() === 60 /* `<` */ &&\r\n            (this.ignoreTag ||\r\n                // If at the opening tag or closing tag position, bail.\r\n                !_isAlphaOrSlash(this.peek() || 0))) {\r\n            this.bump(); // `<`\r\n            return '<';\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\r\n     * a character that requires quoting (that is, \"only where needed\"), and works the same in\r\n     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\r\n     */\r\n    Parser.prototype.tryParseQuote = function (parentArgType) {\r\n        if (this.isEOF() || this.char() !== 39 /* `'` */) {\r\n            return null;\r\n        }\r\n        // Parse escaped char following the apostrophe, or early return if there is no escaped char.\r\n        // Check if is valid escaped character\r\n        switch (this.peek()) {\r\n            case 39 /* `'` */:\r\n                // double quote, should return as a single quote.\r\n                this.bump();\r\n                this.bump();\r\n                return \"'\";\r\n            // '{', '<', '>', '}'\r\n            case 123:\r\n            case 60:\r\n            case 62:\r\n            case 125:\r\n                break;\r\n            case 35: // '#'\r\n                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\r\n                    break;\r\n                }\r\n                return null;\r\n            default:\r\n                return null;\r\n        }\r\n        this.bump(); // apostrophe\r\n        var codePoints = [this.char()]; // escaped char\r\n        this.bump();\r\n        // read chars until the optional closing apostrophe is found\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            if (ch === 39 /* `'` */) {\r\n                if (this.peek() === 39 /* `'` */) {\r\n                    codePoints.push(39);\r\n                    // Bump one more time because we need to skip 2 characters.\r\n                    this.bump();\r\n                }\r\n                else {\r\n                    // Optional closing apostrophe.\r\n                    this.bump();\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                codePoints.push(ch);\r\n            }\r\n            this.bump();\r\n        }\r\n        return fromCodePoint.apply(void 0, codePoints);\r\n    };\r\n    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\r\n        if (this.isEOF()) {\r\n            return null;\r\n        }\r\n        var ch = this.char();\r\n        if (ch === 60 /* `<` */ ||\r\n            ch === 123 /* `{` */ ||\r\n            (ch === 35 /* `#` */ &&\r\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||\r\n            (ch === 125 /* `}` */ && nestingLevel > 0)) {\r\n            return null;\r\n        }\r\n        else {\r\n            this.bump();\r\n            return fromCodePoint(ch);\r\n        }\r\n    };\r\n    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\r\n        var openingBracePosition = this.clonePosition();\r\n        this.bump(); // `{`\r\n        this.bumpSpace();\r\n        if (this.isEOF()) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        if (this.char() === 125 /* `}` */) {\r\n            this.bump();\r\n            return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        // argument name\r\n        var value = this.parseIdentifierIfPossible().value;\r\n        if (!value) {\r\n            return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        this.bumpSpace();\r\n        if (this.isEOF()) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        switch (this.char()) {\r\n            // Simple argument: `{name}`\r\n            case 125 /* `}` */: {\r\n                this.bump(); // `}`\r\n                return {\r\n                    val: {\r\n                        type: TYPE.argument,\r\n                        // value does not include the opening and closing braces.\r\n                        value: value,\r\n                        location: createLocation(openingBracePosition, this.clonePosition()),\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            // Argument with options: `{name, format, ...}`\r\n            case 44 /* `,` */: {\r\n                this.bump(); // `,`\r\n                this.bumpSpace();\r\n                if (this.isEOF()) {\r\n                    return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n                }\r\n                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\r\n            }\r\n            default:\r\n                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n    };\r\n    /**\r\n     * Advance the parser until the end of the identifier, if it is currently on\r\n     * an identifier character. Return an empty string otherwise.\r\n     */\r\n    Parser.prototype.parseIdentifierIfPossible = function () {\r\n        var startingPosition = this.clonePosition();\r\n        var startOffset = this.offset();\r\n        var value = matchIdentifierAtIndex(this.message, startOffset);\r\n        var endOffset = startOffset + value.length;\r\n        this.bumpTo(endOffset);\r\n        var endPosition = this.clonePosition();\r\n        var location = createLocation(startingPosition, endPosition);\r\n        return { value: value, location: location };\r\n    };\r\n    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\r\n        var _a;\r\n        // Parse this range:\r\n        // {name, type, style}\r\n        //        ^---^\r\n        var typeStartPosition = this.clonePosition();\r\n        var argType = this.parseIdentifierIfPossible().value;\r\n        var typeEndPosition = this.clonePosition();\r\n        switch (argType) {\r\n            case '':\r\n                // Expecting a style string number, date, time, plural, selectordinal, or select.\r\n                return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\r\n            case 'number':\r\n            case 'date':\r\n            case 'time': {\r\n                // Parse this range:\r\n                // {name, number, style}\r\n                //              ^-------^\r\n                this.bumpSpace();\r\n                var styleAndLocation = null;\r\n                if (this.bumpIf(',')) {\r\n                    this.bumpSpace();\r\n                    var styleStartPosition = this.clonePosition();\r\n                    var result = this.parseSimpleArgStyleIfPossible();\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    var style = trimEnd(result.val);\r\n                    if (style.length === 0) {\r\n                        return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\r\n                    }\r\n                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());\r\n                    styleAndLocation = { style: style, styleLocation: styleLocation };\r\n                }\r\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n                if (argCloseResult.err) {\r\n                    return argCloseResult;\r\n                }\r\n                var location_1 = createLocation(openingBracePosition, this.clonePosition());\r\n                // Extract style or skeleton\r\n                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\r\n                    // Skeleton starts with `::`.\r\n                    var skeleton = trimStart(styleAndLocation.style.slice(2));\r\n                    if (argType === 'number') {\r\n                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\r\n                        if (result.err) {\r\n                            return result;\r\n                        }\r\n                        return {\r\n                            val: { type: TYPE.number, value: value, location: location_1, style: result.val },\r\n                            err: null,\r\n                        };\r\n                    }\r\n                    else {\r\n                        if (skeleton.length === 0) {\r\n                            return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\r\n                        }\r\n                        var style = {\r\n                            type: SKELETON_TYPE.dateTime,\r\n                            pattern: skeleton,\r\n                            location: styleAndLocation.styleLocation,\r\n                            parsedOptions: this.shouldParseSkeletons\r\n                                ? parseDateTimeSkeleton(skeleton)\r\n                                : {},\r\n                        };\r\n                        var type = argType === 'date' ? TYPE.date : TYPE.time;\r\n                        return {\r\n                            val: { type: type, value: value, location: location_1, style: style },\r\n                            err: null,\r\n                        };\r\n                    }\r\n                }\r\n                // Regular style or no style.\r\n                return {\r\n                    val: {\r\n                        type: argType === 'number'\r\n                            ? TYPE.number\r\n                            : argType === 'date'\r\n                                ? TYPE.date\r\n                                : TYPE.time,\r\n                        value: value,\r\n                        location: location_1,\r\n                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            case 'plural':\r\n            case 'selectordinal':\r\n            case 'select': {\r\n                // Parse this range:\r\n                // {name, plural, options}\r\n                //              ^---------^\r\n                var typeEndPosition_1 = this.clonePosition();\r\n                this.bumpSpace();\r\n                if (!this.bumpIf(',')) {\r\n                    return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\r\n                }\r\n                this.bumpSpace();\r\n                // Parse offset:\r\n                // {name, plural, offset:1, options}\r\n                //                ^-----^\r\n                //\r\n                // or the first option:\r\n                //\r\n                // {name, plural, one {...} other {...}}\r\n                //                ^--^\r\n                var identifierAndLocation = this.parseIdentifierIfPossible();\r\n                var pluralOffset = 0;\r\n                if (argType !== 'select' && identifierAndLocation.value === 'offset') {\r\n                    if (!this.bumpIf(':')) {\r\n                        return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\r\n                    }\r\n                    this.bumpSpace();\r\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    // Parse another identifier for option parsing\r\n                    this.bumpSpace();\r\n                    identifierAndLocation = this.parseIdentifierIfPossible();\r\n                    pluralOffset = result.val;\r\n                }\r\n                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\r\n                if (optionsResult.err) {\r\n                    return optionsResult;\r\n                }\r\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n                if (argCloseResult.err) {\r\n                    return argCloseResult;\r\n                }\r\n                var location_2 = createLocation(openingBracePosition, this.clonePosition());\r\n                if (argType === 'select') {\r\n                    return {\r\n                        val: {\r\n                            type: TYPE.select,\r\n                            value: value,\r\n                            options: fromEntries(optionsResult.val),\r\n                            location: location_2,\r\n                        },\r\n                        err: null,\r\n                    };\r\n                }\r\n                else {\r\n                    return {\r\n                        val: {\r\n                            type: TYPE.plural,\r\n                            value: value,\r\n                            options: fromEntries(optionsResult.val),\r\n                            offset: pluralOffset,\r\n                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\r\n                            location: location_2,\r\n                        },\r\n                        err: null,\r\n                    };\r\n                }\r\n            }\r\n            default:\r\n                return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\r\n        }\r\n    };\r\n    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\r\n        // Parse: {value, number, ::currency/GBP }\r\n        //\r\n        if (this.isEOF() || this.char() !== 125 /* `}` */) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        this.bump(); // `}`\r\n        return { val: true, err: null };\r\n    };\r\n    /**\r\n     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\r\n     */\r\n    Parser.prototype.parseSimpleArgStyleIfPossible = function () {\r\n        var nestedBraces = 0;\r\n        var startPosition = this.clonePosition();\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            switch (ch) {\r\n                case 39 /* `'` */: {\r\n                    // Treat apostrophe as quoting but include it in the style part.\r\n                    // Find the end of the quoted literal text.\r\n                    this.bump();\r\n                    var apostrophePosition = this.clonePosition();\r\n                    if (!this.bumpUntil(\"'\")) {\r\n                        return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\r\n                    }\r\n                    this.bump();\r\n                    break;\r\n                }\r\n                case 123 /* `{` */: {\r\n                    nestedBraces += 1;\r\n                    this.bump();\r\n                    break;\r\n                }\r\n                case 125 /* `}` */: {\r\n                    if (nestedBraces > 0) {\r\n                        nestedBraces -= 1;\r\n                    }\r\n                    else {\r\n                        return {\r\n                            val: this.message.slice(startPosition.offset, this.offset()),\r\n                            err: null,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    this.bump();\r\n                    break;\r\n            }\r\n        }\r\n        return {\r\n            val: this.message.slice(startPosition.offset, this.offset()),\r\n            err: null,\r\n        };\r\n    };\r\n    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\r\n        var tokens = [];\r\n        try {\r\n            tokens = parseNumberSkeletonFromString(skeleton);\r\n        }\r\n        catch (e) {\r\n            return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\r\n        }\r\n        return {\r\n            val: {\r\n                type: SKELETON_TYPE.number,\r\n                tokens: tokens,\r\n                location: location,\r\n                parsedOptions: this.shouldParseSkeletons\r\n                    ? parseNumberSkeleton(tokens)\r\n                    : {},\r\n            },\r\n            err: null,\r\n        };\r\n    };\r\n    /**\r\n     * @param nesting_level The current nesting level of messages.\r\n     *     This can be positive when parsing message fragment in select or plural argument options.\r\n     * @param parent_arg_type The parent argument's type.\r\n     * @param parsed_first_identifier If provided, this is the first identifier-like selector of\r\n     *     the argument. It is a by-product of a previous parsing attempt.\r\n     * @param expecting_close_tag If true, this message is directly or indirectly nested inside\r\n     *     between a pair of opening and closing tags. The nested message will not parse beyond\r\n     *     the closing tag boundary.\r\n     */\r\n    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\r\n        var _a;\r\n        var hasOtherClause = false;\r\n        var options = [];\r\n        var parsedSelectors = new Set();\r\n        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;\r\n        // Parse:\r\n        // one {one apple}\r\n        // ^--^\r\n        while (true) {\r\n            if (selector.length === 0) {\r\n                var startPosition = this.clonePosition();\r\n                if (parentArgType !== 'select' && this.bumpIf('=')) {\r\n                    // Try parse `={number}` selector\r\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    selectorLocation = createLocation(startPosition, this.clonePosition());\r\n                    selector = this.message.slice(startPosition.offset, this.offset());\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            // Duplicate selector clauses\r\n            if (parsedSelectors.has(selector)) {\r\n                return this.error(parentArgType === 'select'\r\n                    ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR\r\n                    : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\r\n            }\r\n            if (selector === 'other') {\r\n                hasOtherClause = true;\r\n            }\r\n            // Parse:\r\n            // one {one apple}\r\n            //     ^----------^\r\n            this.bumpSpace();\r\n            var openingBracePosition = this.clonePosition();\r\n            if (!this.bumpIf('{')) {\r\n                return this.error(parentArgType === 'select'\r\n                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\r\n                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\r\n            }\r\n            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\r\n            if (fragmentResult.err) {\r\n                return fragmentResult;\r\n            }\r\n            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n            if (argCloseResult.err) {\r\n                return argCloseResult;\r\n            }\r\n            options.push([\r\n                selector,\r\n                {\r\n                    value: fragmentResult.val,\r\n                    location: createLocation(openingBracePosition, this.clonePosition()),\r\n                },\r\n            ]);\r\n            // Keep track of the existing selectors\r\n            parsedSelectors.add(selector);\r\n            // Prep next selector clause.\r\n            this.bumpSpace();\r\n            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);\r\n        }\r\n        if (options.length === 0) {\r\n            return this.error(parentArgType === 'select'\r\n                ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR\r\n                : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\r\n        }\r\n        if (this.requiresOtherClause && !hasOtherClause) {\r\n            return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\r\n        }\r\n        return { val: options, err: null };\r\n    };\r\n    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\r\n        var sign = 1;\r\n        var startingPosition = this.clonePosition();\r\n        if (this.bumpIf('+')) {\r\n        }\r\n        else if (this.bumpIf('-')) {\r\n            sign = -1;\r\n        }\r\n        var hasDigits = false;\r\n        var decimal = 0;\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\r\n                hasDigits = true;\r\n                decimal = decimal * 10 + (ch - 48);\r\n                this.bump();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        var location = createLocation(startingPosition, this.clonePosition());\r\n        if (!hasDigits) {\r\n            return this.error(expectNumberError, location);\r\n        }\r\n        decimal *= sign;\r\n        if (!isSafeInteger(decimal)) {\r\n            return this.error(invalidNumberError, location);\r\n        }\r\n        return { val: decimal, err: null };\r\n    };\r\n    Parser.prototype.offset = function () {\r\n        return this.position.offset;\r\n    };\r\n    Parser.prototype.isEOF = function () {\r\n        return this.offset() === this.message.length;\r\n    };\r\n    Parser.prototype.clonePosition = function () {\r\n        // This is much faster than `Object.assign` or spread.\r\n        return {\r\n            offset: this.position.offset,\r\n            line: this.position.line,\r\n            column: this.position.column,\r\n        };\r\n    };\r\n    /**\r\n     * Return the code point at the current position of the parser.\r\n     * Throws if the index is out of bound.\r\n     */\r\n    Parser.prototype.char = function () {\r\n        var offset = this.position.offset;\r\n        if (offset >= this.message.length) {\r\n            throw Error('out of bound');\r\n        }\r\n        var code = codePointAt(this.message, offset);\r\n        if (code === undefined) {\r\n            throw Error(\"Offset \" + offset + \" is at invalid UTF-16 code unit boundary\");\r\n        }\r\n        return code;\r\n    };\r\n    Parser.prototype.error = function (kind, location) {\r\n        return {\r\n            val: null,\r\n            err: {\r\n                kind: kind,\r\n                message: this.message,\r\n                location: location,\r\n            },\r\n        };\r\n    };\r\n    /** Bump the parser to the next UTF-16 code unit. */\r\n    Parser.prototype.bump = function () {\r\n        if (this.isEOF()) {\r\n            return;\r\n        }\r\n        var code = this.char();\r\n        if (code === 10 /* '\\n' */) {\r\n            this.position.line += 1;\r\n            this.position.column = 1;\r\n            this.position.offset += 1;\r\n        }\r\n        else {\r\n            this.position.column += 1;\r\n            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\r\n            this.position.offset += code < 0x10000 ? 1 : 2;\r\n        }\r\n    };\r\n    /**\r\n     * If the substring starting at the current position of the parser has\r\n     * the given prefix, then bump the parser to the character immediately\r\n     * following the prefix and return true. Otherwise, don't bump the parser\r\n     * and return false.\r\n     */\r\n    Parser.prototype.bumpIf = function (prefix) {\r\n        if (startsWith(this.message, prefix, this.offset())) {\r\n            for (var i = 0; i < prefix.length; i++) {\r\n                this.bump();\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Bump the parser until the pattern character is found and return `true`.\r\n     * Otherwise bump to the end of the file and return `false`.\r\n     */\r\n    Parser.prototype.bumpUntil = function (pattern) {\r\n        var currentOffset = this.offset();\r\n        var index = this.message.indexOf(pattern, currentOffset);\r\n        if (index >= 0) {\r\n            this.bumpTo(index);\r\n            return true;\r\n        }\r\n        else {\r\n            this.bumpTo(this.message.length);\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Bump the parser to the target offset.\r\n     * If target offset is beyond the end of the input, bump the parser to the end of the input.\r\n     */\r\n    Parser.prototype.bumpTo = function (targetOffset) {\r\n        if (this.offset() > targetOffset) {\r\n            throw Error(\"targetOffset \" + targetOffset + \" must be greater than or equal to the current offset \" + this.offset());\r\n        }\r\n        targetOffset = Math.min(targetOffset, this.message.length);\r\n        while (true) {\r\n            var offset = this.offset();\r\n            if (offset === targetOffset) {\r\n                break;\r\n            }\r\n            if (offset > targetOffset) {\r\n                throw Error(\"targetOffset \" + targetOffset + \" is at invalid UTF-16 code unit boundary\");\r\n            }\r\n            this.bump();\r\n            if (this.isEOF()) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    /** advance the parser through all whitespace to the next non-whitespace code unit. */\r\n    Parser.prototype.bumpSpace = function () {\r\n        while (!this.isEOF() && _isWhiteSpace(this.char())) {\r\n            this.bump();\r\n        }\r\n    };\r\n    /**\r\n     * Peek at the *next* Unicode codepoint in the input without advancing the parser.\r\n     * If the input has been exhausted, then this returns null.\r\n     */\r\n    Parser.prototype.peek = function () {\r\n        if (this.isEOF()) {\r\n            return null;\r\n        }\r\n        var code = this.char();\r\n        var offset = this.offset();\r\n        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\r\n        return nextCode !== null && nextCode !== void 0 ? nextCode : null;\r\n    };\r\n    return Parser;\r\n}());\r\nexport { Parser };\r\n/**\r\n * This check if codepoint is alphabet (lower & uppercase)\r\n * @param codepoint\r\n * @returns\r\n */\r\nfunction _isAlpha(codepoint) {\r\n    return ((codepoint >= 97 && codepoint <= 122) ||\r\n        (codepoint >= 65 && codepoint <= 90));\r\n}\r\nfunction _isAlphaOrSlash(codepoint) {\r\n    return _isAlpha(codepoint) || codepoint === 47; /* '/' */\r\n}\r\n/** See `parseTag` function docs. */\r\nfunction _isPotentialElementNameChar(c) {\r\n    return (c === 45 /* '-' */ ||\r\n        c === 46 /* '.' */ ||\r\n        (c >= 48 && c <= 57) /* 0..9 */ ||\r\n        c === 95 /* '_' */ ||\r\n        (c >= 97 && c <= 122) /** a..z */ ||\r\n        (c >= 65 && c <= 90) /* A..Z */ ||\r\n        c == 0xb7 ||\r\n        (c >= 0xc0 && c <= 0xd6) ||\r\n        (c >= 0xd8 && c <= 0xf6) ||\r\n        (c >= 0xf8 && c <= 0x37d) ||\r\n        (c >= 0x37f && c <= 0x1fff) ||\r\n        (c >= 0x200c && c <= 0x200d) ||\r\n        (c >= 0x203f && c <= 0x2040) ||\r\n        (c >= 0x2070 && c <= 0x218f) ||\r\n        (c >= 0x2c00 && c <= 0x2fef) ||\r\n        (c >= 0x3001 && c <= 0xd7ff) ||\r\n        (c >= 0xf900 && c <= 0xfdcf) ||\r\n        (c >= 0xfdf0 && c <= 0xfffd) ||\r\n        (c >= 0x10000 && c <= 0xeffff));\r\n}\r\n/**\r\n * Code point equivalent of regex `\\p{White_Space}`.\r\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\r\nfunction _isWhiteSpace(c) {\r\n    return ((c >= 0x0009 && c <= 0x000d) ||\r\n        c === 0x0020 ||\r\n        c === 0x0085 ||\r\n        (c >= 0x200e && c <= 0x200f) ||\r\n        c === 0x2028 ||\r\n        c === 0x2029);\r\n}\r\n/**\r\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\r\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\r\nfunction _isPatternSyntax(c) {\r\n    return ((c >= 0x0021 && c <= 0x0023) ||\r\n        c === 0x0024 ||\r\n        (c >= 0x0025 && c <= 0x0027) ||\r\n        c === 0x0028 ||\r\n        c === 0x0029 ||\r\n        c === 0x002a ||\r\n        c === 0x002b ||\r\n        c === 0x002c ||\r\n        c === 0x002d ||\r\n        (c >= 0x002e && c <= 0x002f) ||\r\n        (c >= 0x003a && c <= 0x003b) ||\r\n        (c >= 0x003c && c <= 0x003e) ||\r\n        (c >= 0x003f && c <= 0x0040) ||\r\n        c === 0x005b ||\r\n        c === 0x005c ||\r\n        c === 0x005d ||\r\n        c === 0x005e ||\r\n        c === 0x0060 ||\r\n        c === 0x007b ||\r\n        c === 0x007c ||\r\n        c === 0x007d ||\r\n        c === 0x007e ||\r\n        c === 0x00a1 ||\r\n        (c >= 0x00a2 && c <= 0x00a5) ||\r\n        c === 0x00a6 ||\r\n        c === 0x00a7 ||\r\n        c === 0x00a9 ||\r\n        c === 0x00ab ||\r\n        c === 0x00ac ||\r\n        c === 0x00ae ||\r\n        c === 0x00b0 ||\r\n        c === 0x00b1 ||\r\n        c === 0x00b6 ||\r\n        c === 0x00bb ||\r\n        c === 0x00bf ||\r\n        c === 0x00d7 ||\r\n        c === 0x00f7 ||\r\n        (c >= 0x2010 && c <= 0x2015) ||\r\n        (c >= 0x2016 && c <= 0x2017) ||\r\n        c === 0x2018 ||\r\n        c === 0x2019 ||\r\n        c === 0x201a ||\r\n        (c >= 0x201b && c <= 0x201c) ||\r\n        c === 0x201d ||\r\n        c === 0x201e ||\r\n        c === 0x201f ||\r\n        (c >= 0x2020 && c <= 0x2027) ||\r\n        (c >= 0x2030 && c <= 0x2038) ||\r\n        c === 0x2039 ||\r\n        c === 0x203a ||\r\n        (c >= 0x203b && c <= 0x203e) ||\r\n        (c >= 0x2041 && c <= 0x2043) ||\r\n        c === 0x2044 ||\r\n        c === 0x2045 ||\r\n        c === 0x2046 ||\r\n        (c >= 0x2047 && c <= 0x2051) ||\r\n        c === 0x2052 ||\r\n        c === 0x2053 ||\r\n        (c >= 0x2055 && c <= 0x205e) ||\r\n        (c >= 0x2190 && c <= 0x2194) ||\r\n        (c >= 0x2195 && c <= 0x2199) ||\r\n        (c >= 0x219a && c <= 0x219b) ||\r\n        (c >= 0x219c && c <= 0x219f) ||\r\n        c === 0x21a0 ||\r\n        (c >= 0x21a1 && c <= 0x21a2) ||\r\n        c === 0x21a3 ||\r\n        (c >= 0x21a4 && c <= 0x21a5) ||\r\n        c === 0x21a6 ||\r\n        (c >= 0x21a7 && c <= 0x21ad) ||\r\n        c === 0x21ae ||\r\n        (c >= 0x21af && c <= 0x21cd) ||\r\n        (c >= 0x21ce && c <= 0x21cf) ||\r\n        (c >= 0x21d0 && c <= 0x21d1) ||\r\n        c === 0x21d2 ||\r\n        c === 0x21d3 ||\r\n        c === 0x21d4 ||\r\n        (c >= 0x21d5 && c <= 0x21f3) ||\r\n        (c >= 0x21f4 && c <= 0x22ff) ||\r\n        (c >= 0x2300 && c <= 0x2307) ||\r\n        c === 0x2308 ||\r\n        c === 0x2309 ||\r\n        c === 0x230a ||\r\n        c === 0x230b ||\r\n        (c >= 0x230c && c <= 0x231f) ||\r\n        (c >= 0x2320 && c <= 0x2321) ||\r\n        (c >= 0x2322 && c <= 0x2328) ||\r\n        c === 0x2329 ||\r\n        c === 0x232a ||\r\n        (c >= 0x232b && c <= 0x237b) ||\r\n        c === 0x237c ||\r\n        (c >= 0x237d && c <= 0x239a) ||\r\n        (c >= 0x239b && c <= 0x23b3) ||\r\n        (c >= 0x23b4 && c <= 0x23db) ||\r\n        (c >= 0x23dc && c <= 0x23e1) ||\r\n        (c >= 0x23e2 && c <= 0x2426) ||\r\n        (c >= 0x2427 && c <= 0x243f) ||\r\n        (c >= 0x2440 && c <= 0x244a) ||\r\n        (c >= 0x244b && c <= 0x245f) ||\r\n        (c >= 0x2500 && c <= 0x25b6) ||\r\n        c === 0x25b7 ||\r\n        (c >= 0x25b8 && c <= 0x25c0) ||\r\n        c === 0x25c1 ||\r\n        (c >= 0x25c2 && c <= 0x25f7) ||\r\n        (c >= 0x25f8 && c <= 0x25ff) ||\r\n        (c >= 0x2600 && c <= 0x266e) ||\r\n        c === 0x266f ||\r\n        (c >= 0x2670 && c <= 0x2767) ||\r\n        c === 0x2768 ||\r\n        c === 0x2769 ||\r\n        c === 0x276a ||\r\n        c === 0x276b ||\r\n        c === 0x276c ||\r\n        c === 0x276d ||\r\n        c === 0x276e ||\r\n        c === 0x276f ||\r\n        c === 0x2770 ||\r\n        c === 0x2771 ||\r\n        c === 0x2772 ||\r\n        c === 0x2773 ||\r\n        c === 0x2774 ||\r\n        c === 0x2775 ||\r\n        (c >= 0x2794 && c <= 0x27bf) ||\r\n        (c >= 0x27c0 && c <= 0x27c4) ||\r\n        c === 0x27c5 ||\r\n        c === 0x27c6 ||\r\n        (c >= 0x27c7 && c <= 0x27e5) ||\r\n        c === 0x27e6 ||\r\n        c === 0x27e7 ||\r\n        c === 0x27e8 ||\r\n        c === 0x27e9 ||\r\n        c === 0x27ea ||\r\n        c === 0x27eb ||\r\n        c === 0x27ec ||\r\n        c === 0x27ed ||\r\n        c === 0x27ee ||\r\n        c === 0x27ef ||\r\n        (c >= 0x27f0 && c <= 0x27ff) ||\r\n        (c >= 0x2800 && c <= 0x28ff) ||\r\n        (c >= 0x2900 && c <= 0x2982) ||\r\n        c === 0x2983 ||\r\n        c === 0x2984 ||\r\n        c === 0x2985 ||\r\n        c === 0x2986 ||\r\n        c === 0x2987 ||\r\n        c === 0x2988 ||\r\n        c === 0x2989 ||\r\n        c === 0x298a ||\r\n        c === 0x298b ||\r\n        c === 0x298c ||\r\n        c === 0x298d ||\r\n        c === 0x298e ||\r\n        c === 0x298f ||\r\n        c === 0x2990 ||\r\n        c === 0x2991 ||\r\n        c === 0x2992 ||\r\n        c === 0x2993 ||\r\n        c === 0x2994 ||\r\n        c === 0x2995 ||\r\n        c === 0x2996 ||\r\n        c === 0x2997 ||\r\n        c === 0x2998 ||\r\n        (c >= 0x2999 && c <= 0x29d7) ||\r\n        c === 0x29d8 ||\r\n        c === 0x29d9 ||\r\n        c === 0x29da ||\r\n        c === 0x29db ||\r\n        (c >= 0x29dc && c <= 0x29fb) ||\r\n        c === 0x29fc ||\r\n        c === 0x29fd ||\r\n        (c >= 0x29fe && c <= 0x2aff) ||\r\n        (c >= 0x2b00 && c <= 0x2b2f) ||\r\n        (c >= 0x2b30 && c <= 0x2b44) ||\r\n        (c >= 0x2b45 && c <= 0x2b46) ||\r\n        (c >= 0x2b47 && c <= 0x2b4c) ||\r\n        (c >= 0x2b4d && c <= 0x2b73) ||\r\n        (c >= 0x2b74 && c <= 0x2b75) ||\r\n        (c >= 0x2b76 && c <= 0x2b95) ||\r\n        c === 0x2b96 ||\r\n        (c >= 0x2b97 && c <= 0x2bff) ||\r\n        (c >= 0x2e00 && c <= 0x2e01) ||\r\n        c === 0x2e02 ||\r\n        c === 0x2e03 ||\r\n        c === 0x2e04 ||\r\n        c === 0x2e05 ||\r\n        (c >= 0x2e06 && c <= 0x2e08) ||\r\n        c === 0x2e09 ||\r\n        c === 0x2e0a ||\r\n        c === 0x2e0b ||\r\n        c === 0x2e0c ||\r\n        c === 0x2e0d ||\r\n        (c >= 0x2e0e && c <= 0x2e16) ||\r\n        c === 0x2e17 ||\r\n        (c >= 0x2e18 && c <= 0x2e19) ||\r\n        c === 0x2e1a ||\r\n        c === 0x2e1b ||\r\n        c === 0x2e1c ||\r\n        c === 0x2e1d ||\r\n        (c >= 0x2e1e && c <= 0x2e1f) ||\r\n        c === 0x2e20 ||\r\n        c === 0x2e21 ||\r\n        c === 0x2e22 ||\r\n        c === 0x2e23 ||\r\n        c === 0x2e24 ||\r\n        c === 0x2e25 ||\r\n        c === 0x2e26 ||\r\n        c === 0x2e27 ||\r\n        c === 0x2e28 ||\r\n        c === 0x2e29 ||\r\n        (c >= 0x2e2a && c <= 0x2e2e) ||\r\n        c === 0x2e2f ||\r\n        (c >= 0x2e30 && c <= 0x2e39) ||\r\n        (c >= 0x2e3a && c <= 0x2e3b) ||\r\n        (c >= 0x2e3c && c <= 0x2e3f) ||\r\n        c === 0x2e40 ||\r\n        c === 0x2e41 ||\r\n        c === 0x2e42 ||\r\n        (c >= 0x2e43 && c <= 0x2e4f) ||\r\n        (c >= 0x2e50 && c <= 0x2e51) ||\r\n        c === 0x2e52 ||\r\n        (c >= 0x2e53 && c <= 0x2e7f) ||\r\n        (c >= 0x3001 && c <= 0x3003) ||\r\n        c === 0x3008 ||\r\n        c === 0x3009 ||\r\n        c === 0x300a ||\r\n        c === 0x300b ||\r\n        c === 0x300c ||\r\n        c === 0x300d ||\r\n        c === 0x300e ||\r\n        c === 0x300f ||\r\n        c === 0x3010 ||\r\n        c === 0x3011 ||\r\n        (c >= 0x3012 && c <= 0x3013) ||\r\n        c === 0x3014 ||\r\n        c === 0x3015 ||\r\n        c === 0x3016 ||\r\n        c === 0x3017 ||\r\n        c === 0x3018 ||\r\n        c === 0x3019 ||\r\n        c === 0x301a ||\r\n        c === 0x301b ||\r\n        c === 0x301c ||\r\n        c === 0x301d ||\r\n        (c >= 0x301e && c <= 0x301f) ||\r\n        c === 0x3020 ||\r\n        c === 0x3030 ||\r\n        c === 0xfd3e ||\r\n        c === 0xfd3f ||\r\n        (c >= 0xfe45 && c <= 0xfe46));\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}