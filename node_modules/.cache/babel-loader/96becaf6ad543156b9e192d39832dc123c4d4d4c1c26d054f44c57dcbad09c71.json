{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BestFitFormatMatcher = exports.bestFitFormatMatcherScore = void 0;\nvar tslib_1 = require(\"tslib\");\nvar utils_1 = require(\"../utils\");\nvar utils_2 = require(\"./utils\");\nvar skeleton_1 = require(\"./skeleton\");\nfunction isNumericType(t) {\n  return t === 'numeric' || t === '2-digit';\n}\n/**\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\n * with some modifications\n * @param options\n * @param format\n */\nfunction bestFitFormatMatcherScore(options, format) {\n  var score = 0;\n  if (options.hour12 && !format.hour12) {\n    score -= utils_2.removalPenalty;\n  } else if (!options.hour12 && format.hour12) {\n    score -= utils_2.additionPenalty;\n  }\n  for (var _i = 0, DATE_TIME_PROPS_1 = utils_2.DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\n    var prop = DATE_TIME_PROPS_1[_i];\n    var optionsProp = options[prop];\n    var formatProp = format[prop];\n    if (optionsProp === undefined && formatProp !== undefined) {\n      score -= utils_2.additionPenalty;\n    } else if (optionsProp !== undefined && formatProp === undefined) {\n      score -= utils_2.removalPenalty;\n    } else if (optionsProp !== formatProp) {\n      // extra penalty for numeric vs non-numeric\n      if (isNumericType(optionsProp) !== isNumericType(formatProp)) {\n        score -= utils_2.differentNumericTypePenalty;\n      } else {\n        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n        var optionsPropIndex = values.indexOf(optionsProp);\n        var formatPropIndex = values.indexOf(formatProp);\n        var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\n        if (delta === 2) {\n          score -= utils_2.longMorePenalty;\n        } else if (delta === 1) {\n          score -= utils_2.shortMorePenalty;\n        } else if (delta === -1) {\n          score -= utils_2.shortLessPenalty;\n        } else if (delta === -2) {\n          score -= utils_2.longLessPenalty;\n        }\n      }\n    }\n  }\n  return score;\n}\nexports.bestFitFormatMatcherScore = bestFitFormatMatcherScore;\n/**\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\n * Just alias to basic for now\n * @param options\n * @param formats\n * @param implDetails Implementation details\n */\nfunction BestFitFormatMatcher(options, formats) {\n  var bestScore = -Infinity;\n  var bestFormat = formats[0];\n  utils_1.invariant(Array.isArray(formats), 'formats should be a list of things');\n  for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n    var format = formats_1[_i];\n    var score = bestFitFormatMatcherScore(options, format);\n    if (score > bestScore) {\n      bestScore = score;\n      bestFormat = format;\n    }\n  }\n  var skeletonFormat = tslib_1.__assign({}, bestFormat);\n  var patternFormat = {\n    rawPattern: bestFormat.rawPattern\n  };\n  skeleton_1.processDateTimePattern(bestFormat.rawPattern, patternFormat);\n  // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\n  // Method adjustFieldTypes\n  for (var prop in skeletonFormat) {\n    var skeletonValue = skeletonFormat[prop];\n    var patternValue = patternFormat[prop];\n    var requestedValue = options[prop];\n    // Don't mess with minute/second or we can get in the situation of\n    // 7:0:0 which is weird\n    if (prop === 'minute' || prop === 'second') {\n      continue;\n    }\n    // Nothing to do here\n    if (!requestedValue) {\n      continue;\n    }\n    // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n    // Looks like we should not convert numeric to alphabetic but the other way\n    // around is ok\n    if (isNumericType(patternValue) && !isNumericType(requestedValue)) {\n      continue;\n    }\n    if (skeletonValue === requestedValue) {\n      continue;\n    }\n    patternFormat[prop] = requestedValue;\n  }\n  // Copy those over\n  patternFormat.pattern = skeletonFormat.pattern;\n  patternFormat.pattern12 = skeletonFormat.pattern12;\n  patternFormat.skeleton = skeletonFormat.skeleton;\n  patternFormat.rangePatterns = skeletonFormat.rangePatterns;\n  patternFormat.rangePatterns12 = skeletonFormat.rangePatterns12;\n  return patternFormat;\n}\nexports.BestFitFormatMatcher = BestFitFormatMatcher;","map":{"version":3,"names":["Object","defineProperty","exports","value","BestFitFormatMatcher","bestFitFormatMatcherScore","tslib_1","require","utils_1","utils_2","skeleton_1","isNumericType","t","options","format","score","hour12","removalPenalty","additionPenalty","_i","DATE_TIME_PROPS_1","DATE_TIME_PROPS","length","prop","optionsProp","formatProp","undefined","differentNumericTypePenalty","values","optionsPropIndex","indexOf","formatPropIndex","delta","Math","max","min","longMorePenalty","shortMorePenalty","shortLessPenalty","longLessPenalty","formats","bestScore","Infinity","bestFormat","invariant","Array","isArray","formats_1","skeletonFormat","__assign","patternFormat","rawPattern","processDateTimePattern","skeletonValue","patternValue","requestedValue","pattern","pattern12","skeleton","rangePatterns","rangePatterns12"],"sources":["C:/Users/Admin/Desktop/LEARN REACTJS/Frontend-ReactJS-QuickStart/node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/ecma402-abstract/DateTimeFormat/BestFitFormatMatcher.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BestFitFormatMatcher = exports.bestFitFormatMatcherScore = void 0;\nvar tslib_1 = require(\"tslib\");\nvar utils_1 = require(\"../utils\");\nvar utils_2 = require(\"./utils\");\nvar skeleton_1 = require(\"./skeleton\");\nfunction isNumericType(t) {\n    return t === 'numeric' || t === '2-digit';\n}\n/**\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\n * with some modifications\n * @param options\n * @param format\n */\nfunction bestFitFormatMatcherScore(options, format) {\n    var score = 0;\n    if (options.hour12 && !format.hour12) {\n        score -= utils_2.removalPenalty;\n    }\n    else if (!options.hour12 && format.hour12) {\n        score -= utils_2.additionPenalty;\n    }\n    for (var _i = 0, DATE_TIME_PROPS_1 = utils_2.DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\n        var prop = DATE_TIME_PROPS_1[_i];\n        var optionsProp = options[prop];\n        var formatProp = format[prop];\n        if (optionsProp === undefined && formatProp !== undefined) {\n            score -= utils_2.additionPenalty;\n        }\n        else if (optionsProp !== undefined && formatProp === undefined) {\n            score -= utils_2.removalPenalty;\n        }\n        else if (optionsProp !== formatProp) {\n            // extra penalty for numeric vs non-numeric\n            if (isNumericType(optionsProp) !==\n                isNumericType(formatProp)) {\n                score -= utils_2.differentNumericTypePenalty;\n            }\n            else {\n                var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n                var optionsPropIndex = values.indexOf(optionsProp);\n                var formatPropIndex = values.indexOf(formatProp);\n                var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\n                if (delta === 2) {\n                    score -= utils_2.longMorePenalty;\n                }\n                else if (delta === 1) {\n                    score -= utils_2.shortMorePenalty;\n                }\n                else if (delta === -1) {\n                    score -= utils_2.shortLessPenalty;\n                }\n                else if (delta === -2) {\n                    score -= utils_2.longLessPenalty;\n                }\n            }\n        }\n    }\n    return score;\n}\nexports.bestFitFormatMatcherScore = bestFitFormatMatcherScore;\n/**\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\n * Just alias to basic for now\n * @param options\n * @param formats\n * @param implDetails Implementation details\n */\nfunction BestFitFormatMatcher(options, formats) {\n    var bestScore = -Infinity;\n    var bestFormat = formats[0];\n    utils_1.invariant(Array.isArray(formats), 'formats should be a list of things');\n    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n        var format = formats_1[_i];\n        var score = bestFitFormatMatcherScore(options, format);\n        if (score > bestScore) {\n            bestScore = score;\n            bestFormat = format;\n        }\n    }\n    var skeletonFormat = tslib_1.__assign({}, bestFormat);\n    var patternFormat = { rawPattern: bestFormat.rawPattern };\n    skeleton_1.processDateTimePattern(bestFormat.rawPattern, patternFormat);\n    // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\n    // Method adjustFieldTypes\n    for (var prop in skeletonFormat) {\n        var skeletonValue = skeletonFormat[prop];\n        var patternValue = patternFormat[prop];\n        var requestedValue = options[prop];\n        // Don't mess with minute/second or we can get in the situation of\n        // 7:0:0 which is weird\n        if (prop === 'minute' || prop === 'second') {\n            continue;\n        }\n        // Nothing to do here\n        if (!requestedValue) {\n            continue;\n        }\n        // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n        // Looks like we should not convert numeric to alphabetic but the other way\n        // around is ok\n        if (isNumericType(patternValue) &&\n            !isNumericType(requestedValue)) {\n            continue;\n        }\n        if (skeletonValue === requestedValue) {\n            continue;\n        }\n        patternFormat[prop] = requestedValue;\n    }\n    // Copy those over\n    patternFormat.pattern = skeletonFormat.pattern;\n    patternFormat.pattern12 = skeletonFormat.pattern12;\n    patternFormat.skeleton = skeletonFormat.skeleton;\n    patternFormat.rangePatterns = skeletonFormat.rangePatterns;\n    patternFormat.rangePatterns12 = skeletonFormat.rangePatterns12;\n    return patternFormat;\n}\nexports.BestFitFormatMatcher = BestFitFormatMatcher;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}