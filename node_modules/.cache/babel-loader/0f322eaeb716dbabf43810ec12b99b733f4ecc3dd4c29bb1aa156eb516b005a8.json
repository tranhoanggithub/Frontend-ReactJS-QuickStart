{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant } from '../utils';\nimport { DATE_TIME_PROPS, removalPenalty, additionPenalty, differentNumericTypePenalty, longMorePenalty, shortMorePenalty, shortLessPenalty, longLessPenalty } from './utils';\nimport { processDateTimePattern } from './skeleton';\nfunction isNumericType(t) {\n  return t === 'numeric' || t === '2-digit';\n}\n/**\r\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\r\n * with some modifications\r\n * @param options\r\n * @param format\r\n */\nexport function bestFitFormatMatcherScore(options, format) {\n  var score = 0;\n  if (options.hour12 && !format.hour12) {\n    score -= removalPenalty;\n  } else if (!options.hour12 && format.hour12) {\n    score -= additionPenalty;\n  }\n  for (var _i = 0, DATE_TIME_PROPS_1 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\n    var prop = DATE_TIME_PROPS_1[_i];\n    var optionsProp = options[prop];\n    var formatProp = format[prop];\n    if (optionsProp === undefined && formatProp !== undefined) {\n      score -= additionPenalty;\n    } else if (optionsProp !== undefined && formatProp === undefined) {\n      score -= removalPenalty;\n    } else if (optionsProp !== formatProp) {\n      // extra penalty for numeric vs non-numeric\n      if (isNumericType(optionsProp) !== isNumericType(formatProp)) {\n        score -= differentNumericTypePenalty;\n      } else {\n        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n        var optionsPropIndex = values.indexOf(optionsProp);\n        var formatPropIndex = values.indexOf(formatProp);\n        var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\n        if (delta === 2) {\n          score -= longMorePenalty;\n        } else if (delta === 1) {\n          score -= shortMorePenalty;\n        } else if (delta === -1) {\n          score -= shortLessPenalty;\n        } else if (delta === -2) {\n          score -= longLessPenalty;\n        }\n      }\n    }\n  }\n  return score;\n}\n/**\r\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\r\n * Just alias to basic for now\r\n * @param options\r\n * @param formats\r\n * @param implDetails Implementation details\r\n */\nexport function BestFitFormatMatcher(options, formats) {\n  var bestScore = -Infinity;\n  var bestFormat = formats[0];\n  invariant(Array.isArray(formats), 'formats should be a list of things');\n  for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n    var format = formats_1[_i];\n    var score = bestFitFormatMatcherScore(options, format);\n    if (score > bestScore) {\n      bestScore = score;\n      bestFormat = format;\n    }\n  }\n  var skeletonFormat = __assign({}, bestFormat);\n  var patternFormat = {\n    rawPattern: bestFormat.rawPattern\n  };\n  processDateTimePattern(bestFormat.rawPattern, patternFormat);\n  // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\n  // Method adjustFieldTypes\n  for (var prop in skeletonFormat) {\n    var skeletonValue = skeletonFormat[prop];\n    var patternValue = patternFormat[prop];\n    var requestedValue = options[prop];\n    // Don't mess with minute/second or we can get in the situation of\n    // 7:0:0 which is weird\n    if (prop === 'minute' || prop === 'second') {\n      continue;\n    }\n    // Nothing to do here\n    if (!requestedValue) {\n      continue;\n    }\n    // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n    // Looks like we should not convert numeric to alphabetic but the other way\n    // around is ok\n    if (isNumericType(patternValue) && !isNumericType(requestedValue)) {\n      continue;\n    }\n    if (skeletonValue === requestedValue) {\n      continue;\n    }\n    patternFormat[prop] = requestedValue;\n  }\n  // Copy those over\n  patternFormat.pattern = skeletonFormat.pattern;\n  patternFormat.pattern12 = skeletonFormat.pattern12;\n  patternFormat.skeleton = skeletonFormat.skeleton;\n  patternFormat.rangePatterns = skeletonFormat.rangePatterns;\n  patternFormat.rangePatterns12 = skeletonFormat.rangePatterns12;\n  return patternFormat;\n}","map":{"version":3,"names":["__assign","invariant","DATE_TIME_PROPS","removalPenalty","additionPenalty","differentNumericTypePenalty","longMorePenalty","shortMorePenalty","shortLessPenalty","longLessPenalty","processDateTimePattern","isNumericType","t","bestFitFormatMatcherScore","options","format","score","hour12","_i","DATE_TIME_PROPS_1","length","prop","optionsProp","formatProp","undefined","values","optionsPropIndex","indexOf","formatPropIndex","delta","Math","max","min","BestFitFormatMatcher","formats","bestScore","Infinity","bestFormat","Array","isArray","formats_1","skeletonFormat","patternFormat","rawPattern","skeletonValue","patternValue","requestedValue","pattern","pattern12","skeleton","rangePatterns","rangePatterns12"],"sources":["C:/Users/Admin/Desktop/LEARN REACTJS/Frontend-ReactJS-QuickStart/node_modules/@formatjs/ecma402-abstract/lib/DateTimeFormat/BestFitFormatMatcher.js"],"sourcesContent":["import { __assign } from \"tslib\";\r\nimport { invariant } from '../utils';\r\nimport { DATE_TIME_PROPS, removalPenalty, additionPenalty, differentNumericTypePenalty, longMorePenalty, shortMorePenalty, shortLessPenalty, longLessPenalty, } from './utils';\r\nimport { processDateTimePattern } from './skeleton';\r\nfunction isNumericType(t) {\r\n    return t === 'numeric' || t === '2-digit';\r\n}\r\n/**\r\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\r\n * with some modifications\r\n * @param options\r\n * @param format\r\n */\r\nexport function bestFitFormatMatcherScore(options, format) {\r\n    var score = 0;\r\n    if (options.hour12 && !format.hour12) {\r\n        score -= removalPenalty;\r\n    }\r\n    else if (!options.hour12 && format.hour12) {\r\n        score -= additionPenalty;\r\n    }\r\n    for (var _i = 0, DATE_TIME_PROPS_1 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\r\n        var prop = DATE_TIME_PROPS_1[_i];\r\n        var optionsProp = options[prop];\r\n        var formatProp = format[prop];\r\n        if (optionsProp === undefined && formatProp !== undefined) {\r\n            score -= additionPenalty;\r\n        }\r\n        else if (optionsProp !== undefined && formatProp === undefined) {\r\n            score -= removalPenalty;\r\n        }\r\n        else if (optionsProp !== formatProp) {\r\n            // extra penalty for numeric vs non-numeric\r\n            if (isNumericType(optionsProp) !==\r\n                isNumericType(formatProp)) {\r\n                score -= differentNumericTypePenalty;\r\n            }\r\n            else {\r\n                var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\r\n                var optionsPropIndex = values.indexOf(optionsProp);\r\n                var formatPropIndex = values.indexOf(formatProp);\r\n                var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\r\n                if (delta === 2) {\r\n                    score -= longMorePenalty;\r\n                }\r\n                else if (delta === 1) {\r\n                    score -= shortMorePenalty;\r\n                }\r\n                else if (delta === -1) {\r\n                    score -= shortLessPenalty;\r\n                }\r\n                else if (delta === -2) {\r\n                    score -= longLessPenalty;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return score;\r\n}\r\n/**\r\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\r\n * Just alias to basic for now\r\n * @param options\r\n * @param formats\r\n * @param implDetails Implementation details\r\n */\r\nexport function BestFitFormatMatcher(options, formats) {\r\n    var bestScore = -Infinity;\r\n    var bestFormat = formats[0];\r\n    invariant(Array.isArray(formats), 'formats should be a list of things');\r\n    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\r\n        var format = formats_1[_i];\r\n        var score = bestFitFormatMatcherScore(options, format);\r\n        if (score > bestScore) {\r\n            bestScore = score;\r\n            bestFormat = format;\r\n        }\r\n    }\r\n    var skeletonFormat = __assign({}, bestFormat);\r\n    var patternFormat = { rawPattern: bestFormat.rawPattern };\r\n    processDateTimePattern(bestFormat.rawPattern, patternFormat);\r\n    // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\r\n    // Method adjustFieldTypes\r\n    for (var prop in skeletonFormat) {\r\n        var skeletonValue = skeletonFormat[prop];\r\n        var patternValue = patternFormat[prop];\r\n        var requestedValue = options[prop];\r\n        // Don't mess with minute/second or we can get in the situation of\r\n        // 7:0:0 which is weird\r\n        if (prop === 'minute' || prop === 'second') {\r\n            continue;\r\n        }\r\n        // Nothing to do here\r\n        if (!requestedValue) {\r\n            continue;\r\n        }\r\n        // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\r\n        // Looks like we should not convert numeric to alphabetic but the other way\r\n        // around is ok\r\n        if (isNumericType(patternValue) &&\r\n            !isNumericType(requestedValue)) {\r\n            continue;\r\n        }\r\n        if (skeletonValue === requestedValue) {\r\n            continue;\r\n        }\r\n        patternFormat[prop] = requestedValue;\r\n    }\r\n    // Copy those over\r\n    patternFormat.pattern = skeletonFormat.pattern;\r\n    patternFormat.pattern12 = skeletonFormat.pattern12;\r\n    patternFormat.skeleton = skeletonFormat.skeleton;\r\n    patternFormat.rangePatterns = skeletonFormat.rangePatterns;\r\n    patternFormat.rangePatterns12 = skeletonFormat.rangePatterns12;\r\n    return patternFormat;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}