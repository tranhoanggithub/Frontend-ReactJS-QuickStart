{"ast":null,"code":"import { isPromise } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nBroadcastChannel.clearNodeFolder = function (options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n};\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\nvar ENFORCED_OPTIONS;\nBroadcastChannel.enforceOptions = function (options) {\n  ENFORCED_OPTIONS = options;\n}; // PROTOTYPE\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n    if (this.closed) return;\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare.then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n  get type() {\n    return this.method.type;\n  }\n};\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    return broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n  });\n}\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n    var time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\nexport default BroadcastChannel;","map":{"version":3,"names":["isPromise","chooseMethod","fillOptionsWithDefaults","BroadcastChannel","name","options","ENFORCED_OPTIONS","method","_iL","_onML","_addEL","message","internal","_befC","_prepP","_prepareChannel","_pubkey","clearNodeFolder","type","then","Promise","resolve","enforceOptions","prototype","postMessage","msg","closed","Error","_post","postInternal","onmessage","fn","time","microSeconds","listenObj","_removeListenerObject","_addListenerObject","addEventListener","removeEventListener","obj","find","close","_this","awaitPrepare","all","map","_state","broadcastChannel","msgObj","data","channel","maybePromise","create","s","_hasMessageListeners","length","push","_startListening","filter","o","_stopListening","listenerFn","forEach","onMessage"],"sources":["C:/Users/Admin/Desktop/LEARN REACTJS/Frontend-ReactJS-QuickStart/node_modules/broadcast-channel/dist/es/index.js"],"sourcesContent":["import { isPromise } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nBroadcastChannel.clearNodeFolder = function (options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n};\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\n\nvar ENFORCED_OPTIONS;\n\nBroadcastChannel.enforceOptions = function (options) {\n  ENFORCED_OPTIONS = options;\n}; // PROTOTYPE\n\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) return;\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare.then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  }\n\n};\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    return broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\n\nexport default BroadcastChannel;"],"mappings":"AAAA,SAASA,SAAS,QAAQ,WAAW;AACrC,SAASC,YAAY,QAAQ,qBAAqB;AAClD,SAASC,uBAAuB,QAAQ,cAAc;AAEtD,IAAIC,gBAAgB,GAAG,SAASA,gBAAgBA,CAACC,IAAI,EAAEC,OAAO,EAAE;EAC9D,IAAI,CAACD,IAAI,GAAGA,IAAI;EAEhB,IAAIE,gBAAgB,EAAE;IACpBD,OAAO,GAAGC,gBAAgB;EAC5B;EAEA,IAAI,CAACD,OAAO,GAAGH,uBAAuB,CAACG,OAAO,CAAC;EAC/C,IAAI,CAACE,MAAM,GAAGN,YAAY,CAAC,IAAI,CAACI,OAAO,CAAC,CAAC,CAAC;;EAE1C,IAAI,CAACG,GAAG,GAAG,KAAK;EAChB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,KAAK,GAAG,IAAI;EACjB;AACF;AACA;;EAEE,IAAI,CAACC,MAAM,GAAG;IACZC,OAAO,EAAE,EAAE;IACXC,QAAQ,EAAE;EACZ,CAAC;EACD;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,KAAK,GAAG,EAAE;EACf;AACF;AACA;;EAEE,IAAI,CAACC,MAAM,GAAG,IAAI;EAElBC,eAAe,CAAC,IAAI,CAAC;AACvB,CAAC,CAAC,CAAC;;AAEH;AACA;AACA;AACA;AACA;;AAGAZ,gBAAgB,CAACa,OAAO,GAAG,IAAI;AAC/B;AACA;AACA;AACA;;AAEAb,gBAAgB,CAACc,eAAe,GAAG,UAAUZ,OAAO,EAAE;EACpDA,OAAO,GAAGH,uBAAuB,CAACG,OAAO,CAAC;EAC1C,IAAIE,MAAM,GAAGN,YAAY,CAACI,OAAO,CAAC;EAElC,IAAIE,MAAM,CAACW,IAAI,KAAK,MAAM,EAAE;IAC1B,OAAOX,MAAM,CAACU,eAAe,CAAC,CAAC,CAACE,IAAI,CAAC,YAAY;MAC/C,OAAO,IAAI;IACb,CAAC,CAAC;EACJ,CAAC,MAAM;IACL,OAAOC,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;EAC/B;AACF,CAAC;AACD;AACA;AACA;AACA;;AAGA,IAAIf,gBAAgB;AAEpBH,gBAAgB,CAACmB,cAAc,GAAG,UAAUjB,OAAO,EAAE;EACnDC,gBAAgB,GAAGD,OAAO;AAC5B,CAAC,CAAC,CAAC;;AAGHF,gBAAgB,CAACoB,SAAS,GAAG;EAC3BC,WAAW,EAAE,SAASA,WAAWA,CAACC,GAAG,EAAE;IACrC,IAAI,IAAI,CAACC,MAAM,EAAE;MACf,MAAM,IAAIC,KAAK,CAAC,kCAAkC,GAAG,8CAA8C,CAAC;IACtG;IAEA,OAAOC,KAAK,CAAC,IAAI,EAAE,SAAS,EAAEH,GAAG,CAAC;EACpC,CAAC;EACDI,YAAY,EAAE,SAASA,YAAYA,CAACJ,GAAG,EAAE;IACvC,OAAOG,KAAK,CAAC,IAAI,EAAE,UAAU,EAAEH,GAAG,CAAC;EACrC,CAAC;EAED,IAAIK,SAASA,CAACC,EAAE,EAAE;IAChB,IAAIC,IAAI,GAAG,IAAI,CAACzB,MAAM,CAAC0B,YAAY,CAAC,CAAC;IACrC,IAAIC,SAAS,GAAG;MACdF,IAAI,EAAEA,IAAI;MACVD,EAAE,EAAEA;IACN,CAAC;IAEDI,qBAAqB,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC1B,KAAK,CAAC;IAElD,IAAIsB,EAAE,IAAI,OAAOA,EAAE,KAAK,UAAU,EAAE;MAClC,IAAI,CAACtB,KAAK,GAAGyB,SAAS;MAEtBE,kBAAkB,CAAC,IAAI,EAAE,SAAS,EAAEF,SAAS,CAAC;IAChD,CAAC,MAAM;MACL,IAAI,CAACzB,KAAK,GAAG,IAAI;IACnB;EACF,CAAC;EAED4B,gBAAgB,EAAE,SAASA,gBAAgBA,CAACnB,IAAI,EAAEa,EAAE,EAAE;IACpD,IAAIC,IAAI,GAAG,IAAI,CAACzB,MAAM,CAAC0B,YAAY,CAAC,CAAC;IACrC,IAAIC,SAAS,GAAG;MACdF,IAAI,EAAEA,IAAI;MACVD,EAAE,EAAEA;IACN,CAAC;IAEDK,kBAAkB,CAAC,IAAI,EAAElB,IAAI,EAAEgB,SAAS,CAAC;EAC3C,CAAC;EACDI,mBAAmB,EAAE,SAASA,mBAAmBA,CAACpB,IAAI,EAAEa,EAAE,EAAE;IAC1D,IAAIQ,GAAG,GAAG,IAAI,CAAC7B,MAAM,CAACQ,IAAI,CAAC,CAACsB,IAAI,CAAC,UAAUD,GAAG,EAAE;MAC9C,OAAOA,GAAG,CAACR,EAAE,KAAKA,EAAE;IACtB,CAAC,CAAC;IAEFI,qBAAqB,CAAC,IAAI,EAAEjB,IAAI,EAAEqB,GAAG,CAAC;EACxC,CAAC;EACDE,KAAK,EAAE,SAASA,KAAKA,CAAA,EAAG;IACtB,IAAIC,KAAK,GAAG,IAAI;IAEhB,IAAI,IAAI,CAAChB,MAAM,EAAE;IACjB,IAAI,CAACA,MAAM,GAAG,IAAI;IAClB,IAAIiB,YAAY,GAAG,IAAI,CAAC7B,MAAM,GAAG,IAAI,CAACA,MAAM,GAAGM,OAAO,CAACC,OAAO,CAAC,CAAC;IAChE,IAAI,CAACZ,KAAK,GAAG,IAAI;IACjB,IAAI,CAACC,MAAM,CAACC,OAAO,GAAG,EAAE;IACxB,OAAOgC,YAAY,CAACxB,IAAI,CAAC,YAAY;MACnC,OAAOC,OAAO,CAACwB,GAAG,CAACF,KAAK,CAAC7B,KAAK,CAACgC,GAAG,CAAC,UAAUd,EAAE,EAAE;QAC/C,OAAOA,EAAE,CAAC,CAAC;MACb,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAACZ,IAAI,CAAC,YAAY;MAClB,OAAOuB,KAAK,CAACnC,MAAM,CAACkC,KAAK,CAACC,KAAK,CAACI,MAAM,CAAC;IACzC,CAAC,CAAC;EACJ,CAAC;EAED,IAAI5B,IAAIA,CAAA,EAAG;IACT,OAAO,IAAI,CAACX,MAAM,CAACW,IAAI;EACzB;AAEF,CAAC;AAED,SAASU,KAAKA,CAACmB,gBAAgB,EAAE7B,IAAI,EAAEO,GAAG,EAAE;EAC1C,IAAIO,IAAI,GAAGe,gBAAgB,CAACxC,MAAM,CAAC0B,YAAY,CAAC,CAAC;EACjD,IAAIe,MAAM,GAAG;IACXhB,IAAI,EAAEA,IAAI;IACVd,IAAI,EAAEA,IAAI;IACV+B,IAAI,EAAExB;EACR,CAAC;EACD,IAAIkB,YAAY,GAAGI,gBAAgB,CAACjC,MAAM,GAAGiC,gBAAgB,CAACjC,MAAM,GAAGM,OAAO,CAACC,OAAO,CAAC,CAAC;EACxF,OAAOsB,YAAY,CAACxB,IAAI,CAAC,YAAY;IACnC,OAAO4B,gBAAgB,CAACxC,MAAM,CAACiB,WAAW,CAACuB,gBAAgB,CAACD,MAAM,EAAEE,MAAM,CAAC;EAC7E,CAAC,CAAC;AACJ;AAEA,SAASjC,eAAeA,CAACmC,OAAO,EAAE;EAChC,IAAIC,YAAY,GAAGD,OAAO,CAAC3C,MAAM,CAAC6C,MAAM,CAACF,OAAO,CAAC9C,IAAI,EAAE8C,OAAO,CAAC7C,OAAO,CAAC;EAEvE,IAAIL,SAAS,CAACmD,YAAY,CAAC,EAAE;IAC3BD,OAAO,CAACpC,MAAM,GAAGqC,YAAY;IAC7BA,YAAY,CAAChC,IAAI,CAAC,UAAUkC,CAAC,EAAE;MAC7B;;MAEA;AACN;AACA;MACMH,OAAO,CAACJ,MAAM,GAAGO,CAAC;IACpB,CAAC,CAAC;EACJ,CAAC,MAAM;IACLH,OAAO,CAACJ,MAAM,GAAGK,YAAY;EAC/B;AACF;AAEA,SAASG,oBAAoBA,CAACJ,OAAO,EAAE;EACrC,IAAIA,OAAO,CAACxC,MAAM,CAACC,OAAO,CAAC4C,MAAM,GAAG,CAAC,EAAE,OAAO,IAAI;EAClD,IAAIL,OAAO,CAACxC,MAAM,CAACE,QAAQ,CAAC2C,MAAM,GAAG,CAAC,EAAE,OAAO,IAAI;EACnD,OAAO,KAAK;AACd;AAEA,SAASnB,kBAAkBA,CAACc,OAAO,EAAEhC,IAAI,EAAEqB,GAAG,EAAE;EAC9CW,OAAO,CAACxC,MAAM,CAACQ,IAAI,CAAC,CAACsC,IAAI,CAACjB,GAAG,CAAC;EAE9BkB,eAAe,CAACP,OAAO,CAAC;AAC1B;AAEA,SAASf,qBAAqBA,CAACe,OAAO,EAAEhC,IAAI,EAAEqB,GAAG,EAAE;EACjDW,OAAO,CAACxC,MAAM,CAACQ,IAAI,CAAC,GAAGgC,OAAO,CAACxC,MAAM,CAACQ,IAAI,CAAC,CAACwC,MAAM,CAAC,UAAUC,CAAC,EAAE;IAC9D,OAAOA,CAAC,KAAKpB,GAAG;EAClB,CAAC,CAAC;EAEFqB,cAAc,CAACV,OAAO,CAAC;AACzB;AAEA,SAASO,eAAeA,CAACP,OAAO,EAAE;EAChC,IAAI,CAACA,OAAO,CAAC1C,GAAG,IAAI8C,oBAAoB,CAACJ,OAAO,CAAC,EAAE;IACjD;IACA,IAAIW,UAAU,GAAG,SAASA,UAAUA,CAACb,MAAM,EAAE;MAC3CE,OAAO,CAACxC,MAAM,CAACsC,MAAM,CAAC9B,IAAI,CAAC,CAAC4C,OAAO,CAAC,UAAUvB,GAAG,EAAE;QACjD,IAAIS,MAAM,CAAChB,IAAI,IAAIO,GAAG,CAACP,IAAI,EAAE;UAC3BO,GAAG,CAACR,EAAE,CAACiB,MAAM,CAACC,IAAI,CAAC;QACrB;MACF,CAAC,CAAC;IACJ,CAAC;IAED,IAAIjB,IAAI,GAAGkB,OAAO,CAAC3C,MAAM,CAAC0B,YAAY,CAAC,CAAC;IAExC,IAAIiB,OAAO,CAACpC,MAAM,EAAE;MAClBoC,OAAO,CAACpC,MAAM,CAACK,IAAI,CAAC,YAAY;QAC9B+B,OAAO,CAAC1C,GAAG,GAAG,IAAI;QAClB0C,OAAO,CAAC3C,MAAM,CAACwD,SAAS,CAACb,OAAO,CAACJ,MAAM,EAAEe,UAAU,EAAE7B,IAAI,CAAC;MAC5D,CAAC,CAAC;IACJ,CAAC,MAAM;MACLkB,OAAO,CAAC1C,GAAG,GAAG,IAAI;MAClB0C,OAAO,CAAC3C,MAAM,CAACwD,SAAS,CAACb,OAAO,CAACJ,MAAM,EAAEe,UAAU,EAAE7B,IAAI,CAAC;IAC5D;EACF;AACF;AAEA,SAAS4B,cAAcA,CAACV,OAAO,EAAE;EAC/B,IAAIA,OAAO,CAAC1C,GAAG,IAAI,CAAC8C,oBAAoB,CAACJ,OAAO,CAAC,EAAE;IACjD;IACAA,OAAO,CAAC1C,GAAG,GAAG,KAAK;IACnB,IAAIwB,IAAI,GAAGkB,OAAO,CAAC3C,MAAM,CAAC0B,YAAY,CAAC,CAAC;IACxCiB,OAAO,CAAC3C,MAAM,CAACwD,SAAS,CAACb,OAAO,CAACJ,MAAM,EAAE,IAAI,EAAEd,IAAI,CAAC;EACtD;AACF;AAEA,eAAe7B,gBAAgB"},"metadata":{},"sourceType":"module"}